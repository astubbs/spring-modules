<?xml version="1.0" encoding="UTF-8"?>
<chapter id="cci">
  <title>Lucene</title>

  <sect1>
    <title>Introduction</title>

    <para>According to the home page project, "Apache Lucene is a
    high-performance, full-featured text search engine library written
    entirely in Java. It is a technology suitable for nearly any application
    that requires full-text search, especially cross-platform".</para>

    <para>The project is hosted by Apache. It allows to make scalable
    architecture based on distributed indexes and provides several kinds of
    indexes (in-memory, file-system based, database based).</para>

    <para>Spring Modules offers a Lucene support to provide more flexibility
    in its APIs use. It adds some new abstractions to facilitate the
    management of <emphasis>IndexReader</emphasis>,
    <emphasis>IndexWriter</emphasis> and <emphasis>Searcher</emphasis>, the
    index locking and concurrent accesses, the query creation and the results
    extraction. It provides too facilities to index easily sets of files and
    database rows.</para>
  </sect1>

  <sect1>
    <title>Indexing</title>

    <sect2>
      <title>IndexFactory</title>

      <para>The Lucene support introduces a new abstraction to hide the
      getting of index reader and writer behind a factory. This abstraction is
      the <emphasis>IndexFactory</emphasis> class. It allows the support to be
      more flexible, to facilitate the use of design patterns and the index
      management.</para>

      <programlisting>public interface IndexFactory {
  IndexReader getIndexReader();
  IndexWriter getIndexWriter();
}</programlisting>
    </sect2>

    <sect2>
      <title>Configuration</title>

      <para>Spring Modules provides at this time only one index factory based
      on a directory and an analyzer. It provides too support for configuring
      several directory types.</para>

      <sect3>
        <title>Configuring directories</title>

        <para>The base Lucene concept is directory: It represents the index.
        There are several index types and the Lucene support allow you to
        configure a RAM directory and a file system directory with dedicated
        <emphasis>FactoryBean</emphasis>.</para>

        <para>To configure a RAM directory, you need to use the
        <emphasis>RAMDirectoryFactoryBean</emphasis> class.</para>

        <programlisting>&lt;bean id="ramDirectory"
      class="org.springmodules.lucene.index.support.RAMDirectoryFactoryBean"/&gt;</programlisting>

        <para><emphasis>Important note</emphasis>: Remember that a RAM
        directory is not a persistent index.</para>

        <para>To configure a filesystem directory, you need to use the
        <emphasis>FSDirectoryFactoryBean</emphasis> class. The only mandatory
        property is the directory location of the index.</para>

        <programlisting>&lt;bean id="fsDirectory"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/temp/lucene&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para><emphasis>Important note</emphasis>: The sandbox of the Lucene
        project defines other directories like a database one. Spring Modules
        doesn't support these kind of directories at this time.</para>
      </sect3>

      <sect3>
        <title>Configuring a SimpleIndexFactory</title>

        <para>The <emphasis>SimpleIndexFactory</emphasis> class is the default
        factory to manipulate index. It is based on a Lucene directory and a
        default analyzer. To configure it in Spring, you need to use the
        corresponding <emphasis>SimpleIndexFactoryBean</emphasis>
        class.</para>

        <programlisting>&lt;bean id="fsDirectory" class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/temp/lucene&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="indexFactory" class="org.springmodules.lucene.index.support.SimpleIndexFactoryBean"&gt;
  &lt;property name="directory"&gt;&lt;ref local="fsDirectory" /&gt;&lt;/property&gt;
  &lt;property name="analyzer"&gt;
    &lt;bean class="org.apache.lucene.analysis.SimpleAnalyzer"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>This factory is based on the
        <emphasis>IndexReaderFactoryUtils</emphasis> and
        <emphasis>IndexWriterFactoryUtils</emphasis> classes to manage the
        <emphasis>IndexReader</emphasis> and <emphasis>IndexWriter</emphasis>
        creation or getting. You must be aware that opening an index in a
        write mode will lock it until the writer is closed. Moreover some
        operations are forbidden between the reader and the writer (for
        example, a document delete using the reader and document addition
        using the writing).</para>

        <para>For more informations, see the following section about the
        <emphasis>IndexFactory</emphasis> management.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Document type handling</title>

      <para>The support provides a generic way to handle different file
      formats. It allows the indexer to be extended and supports other file
      formats. To make a new handler, we only need to implement the
      <emphasis>DocumentHandler</emphasis> interface which specifies the way
      to construct a Lucene document from an <emphasis>InputStream</emphasis>.
      You can pass informations about the source with the
      <emphasis>description</emphasis> parameter.</para>

      <programlisting>public interface DocumentHandler {
  public Document getDocument(Map description,
                      InputStream inputStream) throws IOException;
}</programlisting>

      <para>The support provides too a dedicated manager with the
      <emphasis>DocumentHandlerManager</emphasis> interface and its default
      implementation,
      <emphasis>SimpleDocumentHandlerManager</emphasis>.</para>

      <para>By default, the text handler is only registred in the manager but
      you can use the registration methods to add
      (<emphasis>registerDocumentHandler</emphasis> method) or remove
      (<emphasis>unregisterDocumentHandler</emphasis> method) one or more
      other handlers. You can get too the handler that match to a string with
      the <emphasis>getDocumentHandler</emphasis> method. If there is no
      matching handler, the method returns null.</para>

      <programlisting>public interface DocumentHandlerManager {
  DocumentHandler getDocumentHandler(String name);
  void registerDefautHandlers();
  void registerDocumentHandler(DocumentMatching matching,
                               FileDocumentHandler handler);
  void unregisterDocumentHandler(DocumentMatching matching);
}</programlisting>

      <para>As you can see in the method signatures, we need to use the
      <emphasis>DocumentMatching</emphasis> interface to specify when the
      handler can be used. It only defines a match method which takes a string
      as parameter. It could be a file name for example.</para>

      <programlisting>public interface DocumentMatching {
  boolean match(String name);
}</programlisting>

      <para>The support provides an implementation,
      <emphasis>DocumentExtensionMatching</emphasis>, that takes into account
      the file extensions. You only have to specify the extension that handler
      the class.</para>

      <para><emphasis>Note</emphasis>: This implementation is interesting for
      an indexing that works directly on files. If you work on streams,
      perhaps this isn't the implementation to use.</para>

      <para>Endly, you can configure in Spring the handlers supporting by the
      manager with the dedicated <emphasis>FactoryBean</emphasis>,
      <emphasis>ExtensionDocumentHandlerManagerFactoryBean</emphasis> and then
      inject it in your components. Here is an example of configuration with
      file extension:</para>

      <programlisting>&lt;bean id="documentHandlerManager" class=
  "org.springmodules.lucene.index.object.file.ExtensionDocumentHandlerManagerFactoryBean"&gt;
  &lt;property name="documentHandlers"&gt;
    &lt;map&gt;
      &lt;entry key="pdf"&gt;
        &lt;bean class=
            "org.springmodules.samples.lucene.index.file.handlers.PdfBoxDocumentHandler"/&gt;
      &lt;/entry&gt;
      &lt;entry key="rtf"&gt;
        &lt;bean class=
         "org.springmodules.samples.lucene.index.file.handlers.DefaultRtfDocumentHandler"/&gt;
      &lt;/entry&gt;
      &lt;entry key="xls"&gt;
        &lt;bean class=
            "org.springmodules.samples.lucene.index.file.handlers.JExcelDocumentHandler"/&gt;
      &lt;/entry&gt;
      &lt;entry key="doc"&gt;
        &lt;bean class=
            "org.springmodules.samples.lucene.index.file.handlers.PoiWordDocumentHandler"/&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para><emphasis>Important note</emphasis>: This manager can be used in
      both template and object approach.</para>
    </sect2>

    <sect2>
      <title>Template approach</title>

      <para>The Lucene support provides a template approach like Spring for
      JDBC, JMS... to manipulate index.</para>

      <para><emphasis>LuceneIndexTemplate</emphasis> is the central class of
      the Lucene support core package
      (<emphasis>org.springmodules.lucene.index.core</emphasis>) for the
      indexing. It simplifies the use of the corresponding Lucene APIs since
      it handles the creation and release of resources and allow you to
      configure declaratively the resource management. This helps to avoid
      common errors like forgetting to always close the index reader/writer.
      It executes the common operations on an index leaving application code
      the way to create or delete a document and questionwork on the index
      (numDoc property, optimization of an index, deleted
      documents...).</para>

      <para><emphasis>Important note</emphasis>: You must be aware that some
      operations have sense only when the index resources are shared between
      several method calls (<emphasis>hasDeletions</emphasis>,
      <emphasis>isDeleted</emphasis>, <emphasis>undeleteDocuments</emphasis>)
      and other are incompatible in the latter context (for example, add
      document and delete one when resources are shared between several
      calls).</para>

      <para><emphasis>Important note</emphasis>: This template can can have an
      index reader and writer opened at the same time.</para>

      <para>The template uses the <emphasis>DocumentCreator</emphasis> and
      <emphasis>DocumentsCreator</emphasis> abstractions to create one or more
      Lucene documents that will be added to an index. For that, they
      respectively define a <emphasis>createDocument</emphasis> and
      <emphasis>createDocuments</emphasis> methods.</para>

      <programlisting>public interface DocumentCreator {
  Document createDocument() throws IOException;
}</programlisting>

      <programlisting>public interface DocumentsCreator {
  List createDocuments() throws IOException;
}</programlisting>

      <para>If you need to create a Lucene <emphasis>Document</emphasis> from
      an <emphasis>InputStream</emphasis>, you must necessarily manage the
      stream outside the template class because the stream must be opened when
      it calls the <emphasis>addDocument</emphasis> method of the Lucene
      <emphasis>IndexWriter</emphasis> class. To allow the management of the
      <emphasis>InputStream</emphasis> by the template, the support introduces
      the <emphasis>InputStreamDocumentCreator</emphasis> interface. Its
      subclasses must implement the self-explanatory
      <emphasis>createInputStream</emphasis> and
      <emphasis>createDocumentFromInputStream</emphasis> methods.</para>

      <programlisting>public interface InputStreamDocumentCreator {
  public InputStream createInputStream() throws IOException;
  public Document createDocumentFromInputStream(
                InputStream inputStream) throws IOException;
}</programlisting>

      <para>An interesting implementation is the
      <emphasis>InputStreamDocumentCreatorWithManager</emphasis> abstract
      class which allows to delegate the document creation to a
      <emphasis>DocumentHandler</emphasis> for the resource. Its subclasses
      must implement the <emphasis>getResourceName</emphasis> method to allow
      the <emphasis>DocumentHandlerManager</emphasis> to select the right
      <emphasis>DocumentHandler</emphasis> and the
      <emphasis>getResourceDescription</emphasis> method to specify its
      mandatory fields.</para>

      <programlisting>public abstract class InputStreamDocumentCreatorWithManager
                                implements InputStreamDocumentCreator {
  public InputStreamDocumentCreatorWithManager(
                  DocumentHandlerManager documentHandlerManager) { ... }
  protected abstract String getResourceName();
  protected abstract Map getResourceDescription();
  public final Document createDocumentFromInputStream(
                     InputStream inputStream) throws IOException { ... }
}</programlisting>

      <para>The template provides several methods to manipulate an
      index.</para>

      <programlisting>public class LuceneIndexTemplate {
  //...
  public void deleteDocument(int internalDocumentId) { ... }
  public void deleteDocument(Term term) { ... }
  public void undeleteDocuments() { ... }
  public boolean isDeleted(int internalDocumentId) { ... }
  public boolean hasDeletions() { ... }
  public void flushDeletes() { ... }
  public int getMaxDoc() { ... }
  public int getNumDocs() { ... }
  public void addDocument(Document document) { ... }
  public void addDocument(Document document,Analyzer analyzer) { ... }
  public void addDocument(DocumentCreator creator) { ... }
  public void addDocument(DocumentCreator creator,Analyzer analyzer) { ... }
  public void addDocument(InputStreamDocumentCreator creator) { ... }
  public void addDocument(InputStreamDocumentCreator creator,Analyzer analyzer) { ... }
  public void addDocuments(List documents) { ... }
  public void addDocuments(List documents,Analyzer) { ... }
  public void addDocuments(DocumentsCreator creator) { ... }
  public void addDocuments(DocumentsCreator creator,Analyzer) { ... }
  public void optimize() { ... }
  //...
}</programlisting>

      <para>Here is a summary table to show which Lucene resource is used by a
      template method:<table frame="all">
          <title>Resource used by the template methods</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry align="center">LuceneIndexTemplate method
                signature</entry>

                <entry align="center">Corresponding resource used</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry align="center">void deleteDocument(int)</entry>

                <entry align="center">IndexReader</entry>
              </row>

              <row>
                <entry align="center">void deleteDocument(Term)</entry>

                <entry align="center">IndexReader</entry>
              </row>

              <row>
                <entry align="center">void undeleteDocuments()</entry>

                <entry align="center">IndexReader</entry>
              </row>

              <row>
                <entry align="center">boolean isDeleted(int)</entry>

                <entry align="center">IndexReader</entry>
              </row>

              <row>
                <entry align="center">boolean hasDeletions()</entry>

                <entry align="center">IndexReader</entry>
              </row>

              <row>
                <entry align="center">void flushDeletes()</entry>

                <entry align="center">IndexReader</entry>
              </row>

              <row>
                <entry align="center">int getMaxDoc()</entry>

                <entry align="center">IndexReader</entry>
              </row>

              <row>
                <entry align="center">int getNumDocs()</entry>

                <entry align="center">IndexReader</entry>
              </row>

              <row>
                <entry align="center">addDocument methods</entry>

                <entry align="center">IndexWriter</entry>
              </row>

              <row>
                <entry align="center">addDocuments methods</entry>

                <entry align="center">IndexWriter</entry>
              </row>

              <row>
                <entry align="center">void optimize()</entry>

                <entry align="center">IndexWriter</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>Here is a using example of the
      <emphasis>LuceneIndexTemplate</emphasis> class use with both the
      <emphasis>DocumentCreator</emphasis> and
      <emphasis>InputStreamDocumentCreator</emphasis> interfaces:</para>

      <programlisting>public class IndexAccessorImpl extends LuceneIndexSupport implements IndexAccessor {
  public void addDocument(final String text) {
    getTemplate().addDocument(new DocumentCreator() {
      public Document createDocument() throws IOException {
        Document document = new Document();
        document.add(Field.UnStored("contents", text));
        document.add(Field.Keyword("type", "text"));
        document.add(Field.Keyword("filename", title));
        return document;
    });
  }

  public void addDocument(final File file) {
    getTemplate().addDocument(new InputStreamDocumentCreatorWithManager(
                                                getDocumentHandlerManager()) {
      public InputStream createInputStream() throws IOException {
        return new FileInputStream(file);
      }
      protected String getResourceName() {
        return file.getPath();
      }
      protected Map getResourceDescription() {
        Map description=new HashMap();
        description.put(DocumentHandler.FILENAME,file.getPath());
        return description;
      }
    });
  }
}</programlisting>

      <para>and the corresponding Spring configuration:</para>

      <programlisting>&lt;bean id="fsDirectory"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/lucene/index&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="indexFactory"
      class="org.springmodules.lucene.index.support.SimpleIndexFactoryBean"&gt;
  &lt;property name="directory"&gt;&lt;ref local="fsDirectory"/&gt;&lt;/property&gt;
  &lt;property name="analyzer"&gt;
    &lt;bean class="org.apache.lucene.analysis.SimpleAnalyzer"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="indexAccessor"
      class="org.springmodules.samples.lucene.index.service.IndexAccessorImpl"&gt;
  &lt;property name="indexFactory"&gt;&lt;ref local="indexFactory"/&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>Finally the index template provides you two callbacks to work
      directly on a <emphasis>IndexReader</emphasis> or
      <emphasis>IndexWriter</emphasis> instance. These callback are based on
      the <emphasis>ReaderCallBack</emphasis> interface:</para>

      <programlisting>public interface ReaderCallback {
  Object doWithReader(IndexReader reader) throws IOException;
}</programlisting>

      <para>and the <emphasis>WriterCallback</emphasis> interface:</para>

      <programlisting>public interface WriterCallback {
  Object doWithWriter(IndexWriter writer) throws IOException;
}</programlisting>

      <para>and are used by two dedicated methods of the template:</para>

      <programlisting>public class LuceneIndexTemplate {
  //...
  public void read(ReaderCallback callback) { ... }
  public void write(WriterCallback callback) { ... }
  // ...
}</programlisting>
    </sect2>

    <sect2>
      <title>Mass indexing approach</title>

      <para>The support offers facilities to index an important number of
      documents or datas from a directory (or a set of directory) or a
      database. It is divided into two parts:</para>

      <itemizedlist>
        <listitem>
          <para>Indexing a directory and its sub directories recursively. This
          approach allows you to register custom handlers to index several
          file types.</para>
        </listitem>

        <listitem>
          <para>Indexing a database. This approach allows you to specify the
          SQL requests in order to get the datas to index. A callback is then
          provided to create a Lucene document from a
          <emphasis>ResultSet</emphasis>. this feature is based on the Spring
          JDBC framework.</para>
        </listitem>
      </itemizedlist>

      <para>Every classes of this approach are located in the
      <emphasis>org.springmodules.lucene.index.object</emphasis> package and
      its sub packages.</para>

      <sect3>
        <title>Indexing directories</title>

        <para>Indexing directories is implemented by the
        <emphasis>DirectoryIndexer</emphasis> class. To use it, you simply
        call its <emphasis>index</emphasis> method which needs the base
        directory. This class will browse this directory and all its sub
        directories, and tries to index every files which have a dedicated
        handler.</para>

        <programlisting>public class DirectoryIndexer extends AbstractIndexer {
  //...
  public void index(String dirToParse) { ... }
  public void index(String dirToParse,boolean optimizeIndex) { ... }
  //...
}</programlisting>

        <para><emphasis>Important note</emphasis>: If you set the
        <emphasis>optimizeIndex</emphasis> parameter as true, the index will
        be optimized after the indexing.</para>

        <para>This class is based on a mechanism to handle different file
        types. It uses the <emphasis>DocumentHandlerManager</emphasis>
        interface seen in the previous section. It allows the indexer to be
        extended and supports other file formats.</para>

        <para>You can add too listeners to be aware of directories and files
        processing. In this case, you only need to implement the
        <emphasis>DocumentIndexingListener</emphasis> on which different
        methods will be called during the indexing. So the implementation will
        receive the following informations:</para>

        <itemizedlist>
          <listitem>
            <para>The indexer begins to handle all the files of a
            directory.</para>
          </listitem>

          <listitem>
            <para>The indexer has ended to handle all the files of a
            directory</para>
          </listitem>

          <listitem>
            <para>The indexing of a file begins.</para>
          </listitem>

          <listitem>
            <para>The indexing of a file is succesful.</para>
          </listitem>

          <listitem>
            <para>The indexing of a file has failed. The exception is provided
            to the callback.</para>
          </listitem>

          <listitem>
            <para>The indexer haven't the specific handler for the file
            type.</para>
          </listitem>
        </itemizedlist>

        <programlisting>public interface DocumentIndexingListener {
  public void beforeIndexingDirectory(File file);
  public void afterIndexingDirectory(File file);

  public void beforeIndexingFile(File file);
  public void afterIndexingFile(File file);
  public void onErrorIndexingFile(File file,Exception ex);
  public void onNotAvailableHandler(File file);
}</programlisting>

        <para>To associate a listener with the indexer, you can simply use its
        <emphasis>addListener</emphasis> method and to remove one, the
        <emphasis>removeListener</emphasis> method.</para>

        <programlisting>public class DirectoryIndexer extends AbstractIndexer {
  //...
  public void addListener(DocumentIndexingListener listener) { ... }
  public void removeListener(DocumentIndexingListener listener) { ... }
  //...
}</programlisting>

        <para>Here is an example of use:</para>

        <programlisting>public class SimpleDirectoryIndexingImpl
                implements DirectoryIndexing,InitializingBean {
  private IndexFactory indexFactory;
  private DocumentHandlerManager documentHandlerManager;
  private DirectoryIndexer indexer;

  public SimpleDirectoryIndexingImpl() {}

  public void afterPropertiesSet() throws Exception {
    if( indexFactory!=null ) {
      throw new IllegalArgumentException("indexFactory is required");
    }
    this.indexer=new DirectoryIndexer(indexFactory,documentHandlerManager);
  }

  public void indexDirectory(String directory) { indexer.index(directory,true); }

  public void prepareListeners() {
    DocumentIndexingListener listener=new DocumentIndexingListener() {
      public void beforeIndexingDirectory(File file) {
        System.out.println("Indexing the directory : "+file.getPath()+" ...");
      }
      public void afterIndexingDirectory(File file) {
        System.out.println(" -&gt; Directory indexed.");
      }
      public void beforeIndexingFile(File file) {
        System.out.println("Indexing the file : "+file.getPath()+" ...");
      }
      public void afterIndexingFile(File file) {
        System.out.println(" -&gt; File indexed ("+duration+").");
      }
      public void onErrorIndexingFile(File file, Exception ex) {
        System.out.println(" -&gt; Error during the indexing : "+ex.getMessage());
      }
      public void onNotAvailableHandler(File file) {
        System.out.println("No handler registred for the file : "+file.getPath()+" ...");
      }
    };
    indexer.addListener(listener);
  }

  public IndexFactory getIndexFactory() { return indexFactory; }
  public void setIndexFactory(IndexFactory factory) { indexFactory = factory; }
  public DocumentHandlerManager getDocumentHandlerManager() {
    return documentHandlerManager;
  }
  public void setDocumentHandlerManager(DocumentHandlerManager manager) {
    documentHandlerManager = manager;
  }
}</programlisting>

        <para>and the corresponding Spring configuration:</para>

        <programlisting>&lt;bean id="fsDirectory"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/temp/lucene&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;bean id="indexFactory"
      class="org.springmodules.lucene.index.support.SimpleIndexFactoryBean"&gt;
  &lt;property name="directory"&gt;&lt;ref local="fsDirectory" /&gt;&lt;/property&gt;
  &lt;property name="analyzer"&gt;
    &lt;bean class="org.apache.lucene.analysis.SimpleAnalyzer"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="documentHandlerManager" class=
 "org.springmodules.lucene.index.object.file.ExtensionDocumentHandlerManagerFactoryBean"&gt;
  ...
&lt;/bean&gt;

&lt;bean id="indexingDirectory"
  class="org.springmodules.samples.lucene.index.console.SimpleDirectoryIndexingImpl"&gt;
  &lt;property name="indexFactory"&gt;&lt;ref local="indexFactory"/&gt;&lt;/property&gt;
  &lt;property name="documentHandlerManager"&gt;
    &lt;ref local="documentHandlerManager"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Indexing databases</title>

        <para>The support for the database indexing looks like the previous.
        It is implemented by the <emphasis>DatabaseIndexer</emphasis> class.
        To use it, you simply use its index method which needs the JDBC
        <emphasis>DataSource</emphasis> to use. This class will execute every
        sql requests registred, and tries to index every corresponding
        resultsets with the dedicated request handlers.</para>

        <programlisting>public class DatabaseIndexer extends AbstractIndexer {
  //...
  public void index(DataSource dataSource) { ... }
  public void index(DataSource dataSource,boolean optimizeIndex) { ... }
  //...
}</programlisting>

        <para><emphasis>Important note</emphasis>: If you set the
        <emphasis>optimizeIndex</emphasis> parameter as true, the index will
        be optimized after the indexing.</para>

        <para>This class is based on a mechanism to handle different queries.
        It allows the indexer to execute every specified requests. To make a
        new handler, we only need to implement the
        <emphasis>SqlDocumentHandler</emphasis> interface which specifies the
        way to construct a Lucene document from a result set.</para>

        <programlisting>public interface SqlDocumentHandler {
  public Document getDocument(SqlRequest request,ResultSet rs) throws SQLException;
}</programlisting>

        <para>As you can see in the method signatures, we need to use the
        <emphasis>SqlRequest</emphasis> class to specify the SQL request to
        execute and its parameters. It defines two constructors according to
        the request (with or without parameters):</para>

        <programlisting>public class SqlRequest {
  //...
  public SqlRequest(String sql) { ... }
  public SqlRequest(String sql,Object[] params,int[] types) { ... }
  //...
}</programlisting>

        <para>To add and remove requests, you can respectively use the
        <emphasis>registerDocumentHandler</emphasis> and
        <emphasis>unregisterDocumentHandler</emphasis> methods.</para>

        <programlisting>public class DatabaseIndexer extends AbstractIndexer {
  //...
  public void registerDocumentHandler(SqlRequest sqlRequest,
                                      SqlDocumentHandler handler) { ... }
  public void unregisterDocumentHandler(SqlRequest sqlRequest) { ... }
  //...
}</programlisting>

        <para>You can add too listeners to be aware of requests processing. In
        this case, you only need to implement the
        <emphasis>DatabaseIndexingListener</emphasis> on which different
        methods will be called during the indexing. So the implementation will
        receive the following informations:</para>

        <itemizedlist>
          <listitem>
            <para>The indexing of a request begins.</para>
          </listitem>

          <listitem>
            <para>The indexing of a request is succesful.</para>
          </listitem>

          <listitem>
            <para>The indexing of a request has failed. The exception is
            provided to the callback.</para>
          </listitem>
        </itemizedlist>

        <programlisting>public interface DatabaseIndexingListener {
  public void beforeIndexingRequest(SqlRequest request);
  public void afterIndexingRequest(SqlRequest request);
  public void onErrorIndexingRequest(SqlRequest request,Exception ex);
}</programlisting>

        <para>To associate a listener with the indexer, you can simply use its
        <emphasis>addListener</emphasis> method.</para>

        <programlisting>public class DatabaseIndexer extends AbstractIndexer {
  //...
  public void addListener(DatabaseIndexingListener listener) { ... }
  public void removeListener(DatabaseIndexingListener listener) { ... }
  //...
}</programlisting>

        <para>Here is an example of use:</para>

        <programlisting>public class SimpleDatabaseIndexingImpl
                  implements DatabaseIndexing,InitializingBean {

  private DataSource dataSource;
  private IndexFactory indexFactory;
  private DatabaseIndexer indexer;

  public SimpleDatabaseIndexingImpl() {}

  public void afterPropertiesSet() throws Exception {
    if( indexFactory!=null ) {
      throw new IllegalArgumentException("indexFactory is required");
    }
    this.indexer=new DatabaseIndexer(indexFactory);
  }

  public void prepareDatabaseHandlers() {
    //Register the request handler for book_page table without parameters
    this.indexer.registerDocumentHandler(
            new SqlRequest("select book_page_text from book_page"),
            new SqlDocumentHandler() {
      public Document getDocument(SqlRequest request,
                                  ResultSet rs) throws SQLException {
        Document document=new Document();
        document.add(Field.Text("contents", rs.getString("book_page_text")));
        document.add(Field.Keyword("request", request.getSql()));
        return document;
      }
    });

    //Register the request handler for book_page table with parameters
    /*this.indexer.registerDocumentHandler(
           new SqlRequest("select book_page_text from book_page where book_id=?",
                        new Object[] {new Integer(1)},new int[] {Types.INTEGER}),
           new SqlDocumentHandler() {
      public Document getDocument(SqlRequest request,
                                  ResultSet rs) throws SQLException {
         Document document=new Document();
         document.add(Field.Text("contents", rs.getString("book_page_text")));
         document.add(Field.Keyword("request", sql));
         return document;
       }
    });*/
  }

  public void indexDatabase() {
    indexer.index(dataSource,true);
  }

  public void prepareListeners() {
    DatabaseIndexingListener listener=new DatabaseIndexingListener() {
      public void beforeIndexingRequest(SqlRequest request) {
        System.out.println("Indexing the request : "+request.getSql()+" ...");
      }
      public void afterIndexingRequest(SqlRequest request) {
        System.out.println(" -&gt; request indexed.");
      }
      public void onErrorIndexingRequest(SqlRequest request, Exception ex) {
        System.out.println(" -&gt; Error during the indexing : "+ex.getMessage());
      }
    };
    indexer.addListener(listener);
  }

  public IndexFactory getIndexFactory() { return indexFactory; }
  public void setIndexFactory(IndexFactory factory) { indexFactory = factory; }
  public DataSource getDataSource() { return dataSource; }
  public void setDataSource(DataSource source) { dataSource = source; }
}</programlisting>

        <para>and the corresponding Spring configuration:</para>

        <programlisting>&lt;bean id="dataSource"
      class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
  &lt;property name="driverClassName"&gt;
    &lt;value&gt;org.hsqldb.jdbcDriver&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="url"&gt;
    &lt;value&gt;jdbc:hsqldb:hsql://localhost:9001&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="username"&gt;&lt;value&gt;sa&lt;/value&gt;&lt;/property&gt;
  &lt;property name="password"&gt;&lt;value/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="fsDirectory"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/temp/lucene&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="indexFactory"
      class="org.springmodules.lucene.index.support.SimpleIndexFactoryBean"&gt;
  &lt;property name="directory"&gt;&lt;ref local="fsDirectory" /&gt;&lt;/property&gt;
  &lt;property name="analyzer"&gt;
    &lt;bean class="org.apache.lucene.analysis.SimpleAnalyzer"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="indexingDatabase"
   class="org.springmodules.samples.lucene.index.console.SimpleDatabaseIndexingImpl"&gt;
  &lt;property name="indexFactory"&gt;&lt;ref local="indexFactory"/&gt;&lt;/property&gt;
  &lt;property name="dataSource"&gt;&lt;ref local="dataSource"/&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>[TODO: indexing of blob database row field]</para>
      </sect3>
    </sect2>

    <sect2>
      <title>IndexFactory management</title>

      <para>Spring Modules provides support to keep opened
      <emphasis>IndexReader</emphasis> and/or <emphasis>IndexWriter</emphasis>
      between several calls using the resources. Therefore, some template
      methods are useful only in a context where resources remain opened
      between several calls (<emphasis>hasDeletions</emphasis>,
      <emphasis>isDeleted</emphasis>, <emphasis>undeleteAll</emphasis>
      methods).</para>

      <para>By default, every classes using <emphasis>IndexFactory</emphasis>
      create a new <emphasis>IndexReader</emphasis> or
      <emphasis>IndexWriter</emphasis> according to their features and close
      them before the end of the calls. So it prevents to remain the index
      reader and writer opened during a long time.</para>

      <para>However, you can overwrite this mechanism using a dedicated
      template or interceptor to bind these resources in a
      <emphasis>ThreadLocal</emphasis>. Every
      <emphasis>IndexFactory</emphasis> will check this
      <emphasis>ThreadLocal</emphasis> to determine the resource to use (a new
      or one yet opened).</para>

      <para>[TO FINISH]</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Search</title>

    <sect2>
      <title>SearchFactory</title>

      <para>The Lucene support introduces a new abstraction to hide the
      getting of index searchers in a dedicated factory. This abstraction is
      the <emphasis>SearcherFactory</emphasis> class. It allows the support to
      be more flexible and configure directly the used
      <emphasis>Searcher</emphasis> in Spring. The factory instance will be
      then injected in every component to make searchs across one or several
      indexes.</para>

      <programlisting>public interface SearcherFactory {
  Searcher getSearcher() throws IOException;
}</programlisting>

      <para><emphasis>Note</emphasis>: If you need to call methods only
      available in sub classes, you cn use the
      <emphasis>SearcherCallback</emphasis> and cast the searcher to this sub
      class. We describe the callback feature in a later section.</para>
    </sect2>

    <sect2>
      <title>Configuration</title>

      <para>Spring provides several factories to make searchs on a single
      index, on several indexes in a simple or parallel maner and on one or
      several remote indexes.</para>

      <sect3>
        <title>Configuring a SimpleSearcherFactory</title>

        <para>This class is the simplest factory to get a searcher. This
        factory is only based on a single index.</para>

        <programlisting>&lt;bean id="fsDirectory"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/lucene/index1/&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="searcherFactory"
      class="org.springmodules.lucene.search.factory.SimpleSearcherFactory"&gt;
  &lt;property name="directory"&gt;&lt;ref local="fsDirectory" /&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Configuring a MultipleSearcherFactory</title>

        <para>This class allows you to make searchs across several indexes. It
        is based on the Lucene <emphasis>MultiSearcher</emphasis>
        class.</para>

        <programlisting>&lt;bean id="fsDirectory1"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/lucene/index1/&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="fsDirectory2"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/lucene/index2/&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="searcherFactory"
      class="org.springmodules.lucene.search.factory.MultipleSearcherFactory"&gt;
  &lt;property name="directories"&gt;
    &lt;list&gt;
      &lt;ref local="fsDirectory1"/&gt;
      &lt;ref local="fsDirectory2"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Configuring a ParallelMultipleSearcherFactory</title>

        <para>This class allows you to make searchs across several indexes in
        a parallel manner. It is based on the Lucene
        <emphasis>ParallelMultiSearcher</emphasis> class.</para>

        <programlisting>&lt;bean id="fsDirectory1"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/lucene/index1/&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="fsDirectory2"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/lucene/index2/&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="searcherFactory"
   class="org.springmodules.lucene.search.factory.ParallelMultipleSearcherFactory"&gt;
  &lt;property name="directories"&gt;
    &lt;list&gt;
      &lt;ref local="fsDirectory1"/&gt;
      &lt;ref local="fsDirectory2"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Configuring a remote SearcherFactory</title>

        <para>[TODO]</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Make a search</title>

      <sect3>
        <title>Template approach</title>

        <para>The Lucene support provides a template approach like Spring for
        JDBC, JMS... to make searchs.</para>

        <para><emphasis>LuceneSearchTemplate</emphasis> is the central class
        of the Lucene support core package
        (<emphasis>org.springmodules.lucene.search.core</emphasis>) for the
        search. It simplifies the use of the corresponding Lucene APIs since
        it handles the creation and release of resources. This helps to avoid
        common errors like forgetting to always close the searcher. It
        executes the search leaving application code the way to create a
        search query and extract datas from results.</para>

        <para>The template uses the <emphasis>QueryCreator</emphasis>
        abstraction to create a query. For that, it defines a
        <emphasis>createQuery</emphasis> method which must be
        implemented.</para>

        <programlisting>public interface QueryCreator {
  public Query createQuery(Analyzer analyzer) throws ParseException;
}</programlisting>

        <para><emphasis>Note</emphasis>: If you don't inject an
        <emphasis>Analyzer</emphasis> instance in the template, this parameter
        will be null, but perhaps you don't need it to construct your
        query.</para>

        <para>The support provides a <emphasis>ParsedQueryCreator</emphasis>
        implementation to help to construct a query based on a
        <emphasis>QueryParser</emphasis> or a
        <emphasis>MultiFieldQueryParser</emphasis>. It uses an inner class
        <emphasis>QueryParams</emphasis> to hold the document fields to use
        and the query string. This class is used at the query creation and
        must be created by the <emphasis>configureQuery</emphasis> method. If
        you need to configure the created query (for example with a call of
        the <emphasis>setBoost</emphasis> method), you must overwrite the
        <emphasis>setQueryProperties</emphasis> method which gives it as
        method parameter.</para>

        <programlisting>public abstract class ParsedQueryCreator implements QueryCreator {
  public abstract QueryParams configureQuery();
  protected void setQueryProperties(Query query) { }

  public final Query createQuery(Analyzer analyzer)
                                     throws ParseException { ... }
}</programlisting>

        <para>The template provides several methods to make a search for
        different usages (use of <emphasis>Filter</emphasis>,
        <emphasis>Sort</emphasis> and
        <emphasis>HitCollector</emphasis>):</para>

        <programlisting>public class LuceneSearchTemplate {
  //...
  public List search(QueryCreator queryCreator,HitExtractor extractor) { ... }
  public List search(QueryCreator queryCreator,
                                   HitExtractor extractor,Filter filter) { ... }
  public List search(QueryCreator queryCreator,
                                       HitExtractor extractor,Sort sort) { ... }
  public List search(QueryCreator queryCreator,
                         HitExtractor extractor,Filter filter,Sort sort) { ... }
  public void search(QueryCreator queryCreator,HitCollector results) { ... }
  // ...
}</programlisting>

        <para>The following example constructs a query (basing on the
        <emphasis>QueryParser</emphasis> class) to search a text in the
        "contents" property of indexed documents. Then it constructs
        <emphasis>SearchResult</emphasis> objects with the search results.
        These objects will be added in a list by the support.</para>

        <para>Here is the service class using the search template:</para>

        <programlisting>public class SearchServiceImpl extends LuceneSearchSupport
                                    implements SearchService {
  public List search(final String textToSearch) {
    List results=getTemplate().search(new ParsedQueryCreator() {
      public QueryParams configureQuery() {
        return new QueryParams("contents",textToSearch);
      }
    },new HitExtractor() {
      public Object mapHit(int id, Document document, float score) {
        return new SearchResult(document.get("filename"),score);
      }
    }
  });
  return results;
  }
}</programlisting>

        <para>and the corresponding Spring configuration:</para>

        <programlisting>&lt;bean id="fsDirectory"
      class="org.springmodules.lucene.index.support.FSDirectoryFactoryBean"&gt;
  &lt;property name="location"&gt;&lt;value&gt;C:/lucene/index&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="searcherFactory"
      class="org.springmodules.lucene.search.factory.SimpleSearcherFactory"&gt;
  &lt;property name="directory"&gt;&lt;ref local="fsDirectory"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="searchService"
      class="org.springmodules.samples.lucene.searching.service.SearchServiceImpl"&gt;
  &lt;property name="searcherFactory"&gt;&lt;ref bean="searcherFactory" /&gt;&lt;/property&gt;
  &lt;property name="analyzer"&gt;
    &lt;bean class="org.apache.lucene.analysis.SimpleAnalyzer"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>Finally the search template provides you a callback to work
        directly on a <emphasis>Searcher</emphasis> instance. You can use this
        method to cast the Searcher to its current implementation and call
        methods that aren't available at the <emphasis>Searcher</emphasis>
        level. The callback is based on the
        <emphasis>SearcherCallback</emphasis> interface:</para>

        <programlisting>public interface SearcherCallback {
  public Object doWithSearcher(Searcher searcher)
                             throws IOException,ParseException;
}</programlisting>

        <para>and is used by a dedicated <emphasis>search</emphasis> method of
        the template:</para>

        <programlisting>public class LuceneSearchTemplate {
  //...
  public Object search(SearcherCallback callback) { ... }
  // ...
}</programlisting>
      </sect3>

      <sect3>
        <title>Object approach</title>

        <para>The Lucene support provides the conception of search queries as
        object. Every classes of this approach are based on the
        <emphasis>LuceneSearchTemplate</emphasis> class.</para>

        <para>The base class is <emphasis>LuceneSearchQuery</emphasis>. It
        configures the template by allowing you to inject the
        <emphasis>SearcherFactory</emphasis> and <emphasis>Analyzer</emphasis>
        you want to use. As this class is abstract, you must implement the
        <emphasis>search</emphasis> method to specify the way to make your
        search and how handle the results.</para>

        <programlisting>public abstract class LuceneSearchQuery {
  private LuceneSearchTemplate template = new LuceneSearchTemplate();

  public LuceneSearchTemplate getTemplate() { ... }
  public void setAnalyzer(Analyzer analyzer) { ... }
  public void setSearcherFactory(SearcherFactory factory) { ... }

  public abstract List search(String textToSearch);
}</programlisting>

        <para>As this class is very generic, Spring Modules providers a simple
        sub class to help you to implement your search queries. The abstract
        <emphasis>SimpleLuceneSearchQuery</emphasis> class implements the
        search methods leaving you to construct the query and specify the way
        to extract the results.</para>

        <programlisting>public abstract class SimpleLuceneSearchQuery extends LuceneSearchQuery {
  protected abstract Query constructSearchQuery(
                             String textToSearch) throws ParseException;
  protected abstract Object extractResultHit(int id,
                                        Document document, float score);

  public final List search(String textToSearch) { ... }
}</programlisting>

        <para>Here is an example of use:</para>

        <programlisting>String textToSearch=...;
LuceneSearchQuery query=new SimpleLuceneSearchQuery() {
  protected abstract Query constructSearchQuery(
                             String textToSearch) throws ParseException;
    QueryParser parser=new QueryParser("contents",getAnalyzer());
    return parser.parse(textToSearch);
  }

  protected abstract Object extractResultHit(int id,
                               Document document, float score) {
    return document.get("filename");
  }
};
List results=query.search(textToSearch);</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>SearchFactory management</title>

      <para>Spring Modules provides support to keep opened
      <emphasis>Searcher</emphasis> between several calls using the resource.
      This is useful to avoid several index openings during the execution of
      search queries.</para>

      <para>By default, every classes using
      <emphasis>SearcherFactory</emphasis> create a new
      <emphasis>Searcher</emphasis> according to their configurations and
      close it before the end of the calls.</para>

      <para>However, you can overwrite this mechanism using a dedicated
      template or interceptor to bind these resources in a
      <emphasis>ThreadLocal</emphasis>. Every
      <emphasis>SearcherFactory</emphasis> will check this
      <emphasis>ThreadLocal</emphasis> to determine the resource to use (a new
      or one yet opened).</para>

      <para>[TO FINISH]</para>
    </sect2>
  </sect1>
</chapter>