<chapter id="template">

	<title>Templates</title>

    <sect1 id="template-framework">

        <title>Templates &amp; Template Engines</title>

        <important>
            <para>
                The template module was completely rewritten for 0.9 release. The old version of this module was actually
                experimental and should have never been released. As a consequence, that version will not be mantained or
                supported in any way from 0.9 on.
            </para>
        </important>

        <para>
            The Templates module provides an abstraction over common template engines. This abstraction mainly targets
            frameworks and products developers who don't wish to tie their implementation to a specific template engine.
        </para>

        <sect2>

            <title>Core Constructs &amp; Interfaces</title>

            <para>
                This abstraction is based on the following three core interfaces:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Template - This interface represents the notion of a template that is capable of generating
                        an output based on a given model.

                        <programlisting>public interface Template {

    void generate(OutputStream out, Map model) throws TemplateGenerationException;

    void generate(Writer writer, Map model) throws TemplateGenerationException;

    String generate(Map model) throws TemplateGenerationException;

}</programlisting>
                        All Template's method essentially do the same thing - generate an output (whether by writing
                        it to an output stream, writer, or just generate a string) based on a given model which is
                        abstracted as a Map. Although declared, the <emphasis>TemplateGenerationException</emphasis> is a runtime exception
                        (Actually, all exceptions thrown by all constructs are runtime exceptions). This exception is
                        thrown when for some reason the template could not generate the desired output.

                    </para>
                </listitem>
                <listitem>
                    <para>
                        TemplateEngine - This interface represents the a template engine that is capable of creating
                        the appropriate template based on a template resource. As there are many different template
                        engines out there and each one defines its own template language, a template generated by one
                        engine is naturally different than the one generated by another engine.

                        <programlisting>public interface TemplateEngine {

    Template createTemplate(Resource resource) throws TemplateCreationException;

    Template createTemplate(Resource resource, String encoding) throws TemplateCreationException;

}</programlisting>
                        As seen above, the template engine methods accept a Spring resource as an input (the template
                        definition) and create the appropriate template from it. A runtime
                        <emphasis>TemplateCreationException</emphasis> is thrown when for some reason the engine could
                        not create a template from the given resource (perhaps bad template syntax).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        TemplateResolver - This is essentially a strategy for resolving templates based on a template names.
                        For those who are familiar with Spring MVC, this resembles the ViewResolver.

                        <programlisting>public interface TemplateResolver {

    Template resolve(String name);

    Template resolve(String name, Locale locael);

    Template resolve(String name, String encoding);

    Template resolve(String name, String encoding, Locale locale);



}</programlisting>
                        As we'll see later on, this interface enables defining different strategies by which templates
                        can be loaded/resolved which makes the development of a template base class simple and clean.
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2>

            <title>Supported Template Engines</title>

            <sect3>

                <title>Apache Velocity</title>

                <para>
                    The <emphasis>org.springmodules.template.engine.velocity.VelocityTemplate</emphasis> class is the
                    <ulink url="http://velocity.apache.org/">Apache Velocity</ulink> implementation of the <emphasis>TemplateEngine</emphasis> interface. Under the hood
                    it uses the VelocityEngine that can be configured by setting the appropriate Velocity settings using
                    the <emphasis>setConfiguration(Properties)</emphasis> method. Here is an example how the engine
                    can be configured in Spring application context:
                </para>

                <programlisting>&lt;bean id="engine" class="org.springmodules.template.engine.velocity.VelocityTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
    &lt;property name="configuration"&gt;
        &lt;props&gt;
            &lt;!-- Velocity specific properties --&gt;
            &lt;prop key="velocimacro.context.localscope"&gt;false&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    A common feature among template engines is support for inter-resource referencing. This feature
                    enables the template author to modularize the structure of the templates and practice code reuse.
                    Velocity support this feature using the <emphasis>#include</emphasis> and <emphasis>#parse</emphasis>
                    directives. The <emphasis>VelocityTemplateEngine</emphasis> integrates tightly with Velocity resource
                    management and leverages Spring's resource &amp; resource loader support to resolve the referenced
                    resources. This enables the template author to define the references in the Spring common resource
                    paths. For example:
                </para>

                <programlisting>&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;#parse("classpath:header.vm")&lt;/div&gt;
        &lt;div&gt;
            The content body
        &lt;/div&gt;
        &lt;div&gt;#parse("classpath:footer.vm")&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

                <para>
                    The <emphasis>VelocityTemplateEngine</emphasis> implements Spring's <emphasis>ResourceLoaderAware</emphasis>
                    interface so the application context serves as the resource loader by default.
                </para>

            </sect3>

            <sect3>

                <title>Freemarker</title>

                <para>
                    <ulink url="http://freemarker.sourceforge.net/">Freemarker</ulink> is a mature and feature rich template engine that is well designed and performs well. The
                    <emphasis>org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine</emphasis> class is
                    capable of reading FreeMarker template sources and generate the appropriate FreeMarker templates. The
                    following is an example of application context configuration:
                </para>

                <programlisting>&lt;bean id="freemarker" class="org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
    &lt;property name="settings"&gt;
        &lt;props&gt;
            &lt;prop key="locale"&gt;en_US&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name="sharedVariables"&gt;
        &lt;map&gt;
            &lt;entry key="name" value="${name}"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    As shown above, it is also possible to define variables that will be shared among all templates. In
                    this case the shared variable is configured using a property placeholder.
                </para>

                <para>
                    Like with Velocity, <emphasis>FreemarkerTemplateEngine</emphasis> also leverages Spring's
                    resource support to support inter-resource referencing. This enables writing a template like:
                </para>

                <programlisting>&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;&lt;#include "classpath:header.html" parse=false&gt;&lt;/div&gt;
        &lt;div&gt;
            The content body
        &lt;/div&gt;
        &lt;div&gt;&lt;#include "classpath:footer.ftl"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

            </sect3>

            <sect3>

                <title>Groovy Template</title>

                <para>
                    <ulink url="http://groovy.codehaus.org/Groovy+Templates">Groovy Template</ulink> is a library that ships with groovy which enables writing templates in the groovy
                    language (GString's for those familiar with groovy). While current implementation performance
                    is somewhat lagging behind Velocity and Freemarker, groovy as a template language brings quite
                    a lot of power to the hands of template authors. The
                    <emphasis>org.springmodules.template.engine.groovy.GroovyTemplateEngine</emphasis> is the template
                    engine that create Groovy templates. Here is how this engine would be configured in an application
                    context:
                </para>

                <programlisting>&lt;bean id="groovy" class="org.springmodules.template.engine.groovy.GroovyTemplateEngine"&gt;
    &lt;property name="defaultEncoding" value="UTF-8"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    As seen above, there isn't much to configure when defining a groovy template engine. This engine is
                    much more simplistic and less featured than both Velocity and Freemarker (for example, it has no support
                    inter-template referencing).
                </para>

            </sect3>

        </sect2>

        <sect2>

            <title>Template Resolvers</title>

            <para>
                We've seen how we can create/define the template engines that enables the creation of template of
                different types. However, in order to utilize them to create those actual templates, one needs to first
                load the appropriate template resource and hand it over to the engine. Although it is perfectly valid
                approach, template resolvers come to simplify this process even more.
            </para>

            <para>
                The following are the different types of template resolvers that are provided out-of-the-box:
            </para>

            <sect3>

                <title>BasicTemplateResolver</title>

                <para>
                    As the name suggests, this is a very basic implementation of the <emphasis>TemplateResolver</emphasis>
                    interface. It is configured with a template engine and a resource loader. The resource loader is used
                    to load the template resources based on the template name, while the template engine is used to create
                    the templates from the loaded template resources. In the simplest case, the resolver's <emphasis>resolve(String)</emphasis>
                    calls the resource loader's <emphasis>getResource(String)</emphasis> with the provided template name.
                    This resolver can also (recommended) be configured with an extension. The extension is used to help when
                    resolving using a locale. If no extension is set, the resolver will figure out the extension from
                    the given template name (basically, taking treating the susbstring from the last '.' in the name as
                    the extension). Furthermore, it is also possible to tell the resolver to resolve the locale from
                    the current <emphasis>org.springframework.context.i18n.LocaleContext</emphasis> when the locale is
                    not supplied by the client (or when the client supplies <emphasis>null</emphasis> as the locale).
                    Here is how this resolver can be defined within an application context:
                </para>

                <programlisting>&lt;bean id="resolver" class="org.springmodules.template.resolver.BasicTemplateResolver"&gt;
    &lt;property name="engine" ref="velocity"/&gt;
    &lt;property name="extension" value=".vm"/&gt;
    &lt;property name="resolveLocalFromContextWhenAbsent" value="true"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    The <emphasis>BasicTemplateResolver</emphasis> also implements the <emphasis>ResourceLoaderAware</emphasis>
                    interface, so when defined in the application context, by default the application context is used
                    as the resource loader implementation.
                </para>

                <para>
                    Most of the time you wouldn't choose to use this implementation in your application. As we'll see soon,
                    this class mainly serves as a base class for the other template resolver implementations.
                </para>

            </sect3>

            <sect3>

                <title>CachingTemplateResolver</title>

                <para>
                    This is a simple extension on top of the <emphasis>BasicTemplateResolver</emphasis> which caches
                    the resolved templates by their names. Calling <emphasis>resolve(String)</emphasis> on this resolver
                    for the first time, will go through the same process as with the <emphasis>BasicTemplateResolver</emphasis>
                    but with one difference, just before the resolved template is returned, it is cached internally by
                    its name. As a consequence, the next call for the same template (using the same template name) will
                    just return the cached template.
                </para>

                <para>
                    Although for most cases using a cached template resolver is the preferred choice, there are some things
                    to consider. First, the cache effectiveness high depends on the concrete implementation of the template
                    that is used. For example, it could be that a template is implemented in such a way that every call to
                    <emphasis>generate(Writer, Map)</emphasis> the template resource is being re-read. Another thing to
                    consider is that some engines has a built-in support for automatic reload (that is, when the template
                    source changes, the template is reloaded). For some implementations, caching the template will
                    prevent from the reload to actually work. Hopefully, in a future release we'll have our own support
                    for such reload functionality.
                </para>

            </sect3>

            <sect3>

                <title>SimpleTemplateResolver</title>

                <para>
                    Again, as its name suggests, this is a simple template resolver that extends the caching resolver.
                    It is very likely that you will use this resolver implementation most of the time. In addition to
                    all functionality this resolver inherits from the caching and basic resolver, it one additional
                    features. With this resolver it is possible to define a prefix that when combined with
                    the template name, is used to create the template resource path. Here's how this resolver can be
                    configured within an application context:
                </para>

                <programlisting>&lt;bean id="simpleResolver" class="org.springmodules.template.resolver.SimpleTemplateResolver"&gt;
    &lt;property name="engine" ref="freemarker"/&gt;
    &lt;property name="prefix" value="classpath:/templates/"/&gt;
    &lt;property name="extension" value=".ftl"/&gt;
&lt;/bean&gt;</programlisting>

                <para>
                    In the example above, when trying to resolve a template named "email", the resolver will try to load
                    the template resource from the "classpath:/templates/email.ftl" location, or when the locale is provided
                    the resolver will try one of the following first: classpath:/templates/email_en_US.ftl" and
                    "classpath:/templates/email_en.ftl". This is quite powerful mechanism as it lets you define all
                    template resources in a well defined and proprietary location, while still the user only needs to
                    deal with the logical name of the template (i.e. "email").
                </para>

            </sect3>

        </sect2>

    </sect1>

    <sect1 id="email-framework">

        <title>Email Framework</title>

        <para>
            Spring comes with an out-of-the-box support for emailing services. The main goal of this support is to
            provide a higher abstraction of this type of service and hide all the complexities when dealing with
            the <emphasis>javax.mail</emphasis> and <emphasis>java.activation</emphasis> API.
        </para>

        <para>
            While this abstraction succeeds in what it was set up to do, it only provides a new (simpler) set of API's for the developer to
            work with. When it comes to integrating the email service in an enterprise application, a quite common approach
            is to write as set of templates (using Velocity or FreeMarker) to represent the email body, so instead of having
            the content of the email hardcoded in java, one can customize this content on demand without changing the codebase.
            While this approach is better than the pure programmatic one, it's only a partial solution to the problem as the
            developer still needs to hard code the other properties of the email such as subject, sender, recipients, and more.
        </para>

        <para>
            This email framework tries to answer all these issues by introducing an XML based email descriptor which
            can serve as a template for creating email definitions. This email definitions are then handled appropriately
            by leveraging Spring's mail services.
        </para>

        <sect2>
            <title>Core Constructs &amp; Interfaces</title>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>Email</emphasis> - A simple POJO representing an email message. As opposed to all Spring's
                        <emphasis>MailMessage</emphasis> implementation, this POJO tries to capture all possible data of
                        a mail message as bean properties including normal and embedded (inline) attachements.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>EmailDispatcher</emphasis> - An interface used to send Email messages. Can be seen
                        as Spring's <emphasis>MailSender</emphasis> counterpart which works with <emphasis>Email</emphasis>
                        objects.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>EmailParser</emphasis> - Represents a parser that can read email descriptors, parse
                        them, and create Email objects from them.
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2>
            <title>EML files - Email Descriptor</title>

            <para>
                The email descriptor is a simple XML source describing an email. It holds most (if not all) data
                associated with an email, making it possible to keep all email definitions outside of the code base.
                Below you can find a sample email descriptor:
            </para>

            <para>
                <programlisting>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;email xmlns="http://www.springmodules.org/schema/template/email-1.0"&gt;

    &lt;from name="John Doe"&gt;john@doe.org&lt;/from&gt; <co id="from-co" linkends="from"/>

    &lt;reply-to name="No Reply"&gt;noreply@doe.org&lt;/reply-to&gt; <co id="reply-to-co" linkends="reply-to"/>

    &lt;to&gt; <co id="to-co" linkends="to"/>
        &lt;address name="Client"&gt;client@foo.com&lt;/address&gt; <co id="address-co" linkends="address-to"/>
    &lt;/to&gt;

    &lt;cc&gt; <co id="cc-co" linkends="cc"/>
        &lt;address name="Managing Director"&gt;md@doe.org&lt;/address&gt;
        &lt;address name="VP Marketing"&gt;vpm@doe.org&lt;/address&gt;
    &lt;/cc&gt;

    &lt;bcc&gt; <co id="bcc-co" linkends="bcc"/>
        &lt;address&gt;anonymous@doe.org&lt;/address&gt;
    &lt;/bcc&gt;

    &lt;priority&gt;HIGH&lt;/priority&gt; <co id="priority-co" linkends="priority"/>

    &lt;subject&gt;The subject of the mail&lt;/subject&gt; <co id="subject-co" linkends="subject"/>

    &lt;text-body&gt; <co id="text-body-co" linkends="text-body"/>
        This is the text based body of the email
    &lt;/text-body&gt;

    &lt;html-body&gt; <co id="html-body-co" linkends="html-body"/>
        &lt;![CDATA[
            &lt;html&gt;&lt;body&gt;
                &lt;div&gt;&lt;img src="cid:logo"/&gt;&lt;/div&gt;
                &lt;div&gt;This is the HTML based body of the email&lt;/div&gt;
            &lt;/body&gt;&lt;/html&gt;
        ]]&gt;
    &lt;/html-body&gt;

    &lt;attachments&gt; <co id="attachments-co" linkends="attachments"/>
        &lt;attachment name="Marketing.doc"&gt;classpath:/documents/marketing.doc&lt;/attachment&gt; <co id="attachment-co" linkends="attachment"/>
    &lt;/attachments&gt;

    &lt;inline-attachments&gt; <co id="inline-attachments-co" linkends="inline-attachments"/>
        &lt;attachment name="logo"&gt;classpath:/images/logo.gif&lt;/attachment&gt; <co id="inline-attachment-co" linkends="inline-attachment"/>
    &lt;/inline-attachments&gt;

&lt;/email&gt;</programlisting>

                <calloutlist>
                    <callout arearefs="from-co" id="from">
                        <para>Specifying the sender's email address. The "name" attribute is optional and can be used to define the personal name of the sender.</para>
                    </callout>
                    <callout arearefs="reply-to-co" id="reply-to">
                        <para>An optional element specifying the address to which the recipients should reply</para>
                    </callout>
                    <callout arearefs="to-co" id="to">
                        <para>Holds a list of primary recipient addresses to which this email is sent</para>
                    </callout>
                    <callout arearefs="address-co" id="address">
                        <para>Defines an address. The optional "name" attribute can be used to define a personal name for the address</para>
                    </callout>
                    <callout arearefs="cc-co" id="cc">
                        <para>Holds a list of addresses to which this email is will be cc'ed</para>
                    </callout>
                    <callout arearefs="bcc-co" id="bcc">
                        <para>Holds a list of addresses to which this email is will be bcc'ed</para>
                    </callout>
                    <callout arearefs="priority-co" id="priority">
                        <para>
                            Optional element to specify the priority of the email message. The priority can be on of
                            5 options: LOWEST, LOW, NORMAL, HIGH, and HIGHEST. By default the priority is set to NORMAL.
                        </para>
                    </callout>
                    <callout arearefs="subject-co" id="subject">
                        <para>Specifies the subject of the email</para>
                    </callout>
                    <callout arearefs="text-body-co" id="text-body">
                        <para>Specifies the plain text body of the email</para>
                    </callout>
                    <callout arearefs="html-body-co" id="html-body">
                        <para>Specifies the html body of the email.</para>
                    </callout>
                    <callout arearefs="attachments-co" id="attachments">
                        <para>Holds a list of resources to be attached to the email as normal attachments.</para>
                    </callout>
                    <callout arearefs="attachment-co" id="attachment">
                        <para>
                            Defines an attachment where the name serves as the file name and the value specifies
                            the location of the resource. As we'll later see, the location path is determined by the
                            <emphasis>ResourceLoader</emphasis> implementation that is used by the <emphasis>EmailParser</emphasis>.
                            Most commonly the <emphasis>DefaultResourceLoader</emphasis>.
                        </para>
                    </callout>
                    <callout arearefs="inline-attachments-co" id="inline-attachments">
                        <para>Holds a list of resources to be attached to the email as inline (embedded) attachments.</para>
                    </callout>
                    <callout arearefs="inline-attachment-co" id="inline-attachment">
                        <para>
                            Defines an inline attachment where the "name" serves as the id of the attachment by which it
                            can be referenced in the body of the content (for example, assuming the name is set to "001"
                            , the html body can contain the following image element &lt;img src="cid:theId""/&gt;). Here too
                            the value of the element specifies the location of the resource. As we'll later see, the
                            location path is determined by the <emphasis>ResourceLoader</emphasis> implementation that
                            is used by the <emphasis>EmailParser</emphasis>. Most commonly the <emphasis>DefaultResourceLoader</emphasis>.
                        </para>
                    </callout>
                </calloutlist>
            </para>

            <para>
                This XML based email descriptor is the only descriptor that the framework is delivered with. Nonetheless,
                it is possible to define other descriptors as well. The <emphasis>EmailParser</emphasis> interface enables
                loading an email descriptor resource into an Email object. The default implementation is
                <emphasis>SaxEmailParser</emphasis> with parses the XML based descriptor.
            </para>


        </sect2>

        <sect2>
            <title>Email Dispatcher</title>

            <para>
                The email dispatcher is the heart of this framework. This interface enables sending emails. Here is the
                <emphasis>EmailDispatcher</emphasis> interface:
            </para>

            <programlisting>public interface EmailDispatcher {

    void send(Email email); <co id="email-co" linkends="email"/>

    void send(String emailName); <co id="name-co" linkends="name"/>

    void send(String emailName, Locale locale); <co id="name-locale-co" linkends="name-locale"/>

    void send(String emailName, Map model); <co id="name-model-co" linkends="name-model"/>

    void send(String emailName, Map model, Locale locale); <co id="name-model-locale-co" linkends="name-model-locale"/>

    void send(String emailName, Map model, EmailPreparator preparator); <co id="name-model-preparator-co" linkends="name-model-preparator"/>

    void send(String emailName, Map model, Locale locale, EmailPreparator preparator); <co id="name-model-locale-preparator-co" linkends="name-model-locale-preparator"/>

}</programlisting>

            <para>
                <calloutlist>
                    <callout arearefs="email-co" id="email">
                        <para>
                            Sends the given email
                        </para>
                    </callout>
                    <callout arearefs="name-co" id="name">
                        <para>
                            Resolves and sends the email identified by the given name.
                        </para>
                    </callout>
                    <callout arearefs="name-locale-co" id="name-locale">
                        <para>
                            Resolves and sends the email identified by the given name and locale.
                        </para>
                    </callout>
                    <callout arearefs="name-model-co" id="name-model">
                        <para>
                            Resolves the email identified by the given name, populating it using the given model and
                            sends it.
                        </para>
                    </callout>
                    <callout arearefs="name-model-locale-co" id="name-model-locale">
                        <para>
                            Resolves and sends the email identified by the given name and locale. The resolved email is
                            populated by the given given model.
                        </para>
                    </callout>
                    <callout arearefs="name-model-preparator-co" id="name-model-preparator">
                        <para>
                            Resolves the email identified by the given name, populating it using the given model, preparing
                            it using the given email preparator and sends it.
                        </para>
                    </callout>
                    <callout arearefs="name-model-locale-preparator-co" id="name-model-locale-preparator">
                        <para>
                            Resolves and sends the email identified by the given name and locale. The resolved email is
                            populated by the given model and is prepared by the given preparator prior to dispatch.
                        </para>
                    </callout>
                </calloutlist>
            </para>

            <para>
                As can be seen, there are essentially two ways of sending an email. A direct way which mean the client
                of this interface provides the email to be sent. The other way is more implicit way where the client
                requests the dispatcher to send an email identified by its name and possibly by a specific locale.
            </para>

            <para>
                <emphasis>AbstractEmailDispatcher</emphasis> is a base class for all concrete implementation of this
                interface. The abstract class takes care of resolving and preparing the emails. It does this by first loading the
                appropriate template for the given email, generating the output using the given model, The output is expected
                to be an email descriptor and so an <emphasis>EmailParser</emphasis> is used to parse it to a concrete
                <emphasis>Email</emphasis> object. And last but not least, if necessary, preparing the result email using an
                <emphasis>EmailPreparator</emphasis>. In this implementation, the email name essentially serves as an
                email template name that will eventually be generating the actual emails descriptors.
            </para>

            <para>
                There are four concrete <emphasis>EmailDispatcher</emphasis> implementations:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>ConfigurableEmailDispatcher</emphasis> - This dispatcher is configured with an
                        <emphasis>EmailSender</emphasis> which takes care of the email dispatching task. There are two
                        implmentations of <emphasis>EmailSender</emphasis>: <emphasis>JavaMailEmailSender</emphasis> and
                        <emphasis>SimpleEmailSender</emphasis>. Most of the time, you won't be using this dispatcher
                        but instead use one of the following two.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>JavaMailEmailDispatcher</emphasis> - This dispatcher should be used when configured with
                        a <emphasis>JavaMailSender</emphasis> as the underlying <emphasis>MailSender</emphasis>. It is also
                        possible to configured the <emphasis>JavaMailSender</emphasis> properties (e.g. "host", "port",
                        "protocol", etc..) directly on the dispatcher and let it create a new instance of <emphasis>JavaMailSenderImpl</emphasis>
                        internally.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>SimpleEmailDispatcher</emphasis> - This dispatcher should be used when configured with
                        other <emphasis>MailSender</emphasis> implementations such as <emphasis>CosMailSenderImpl</emphasis>.
                        As <emphasis>MailSender</emphasis> works with <emphasis>SimpleMailMessage</emphasis>, this
                        dispatcher makes sure that only the supported information is extracted from the provided
                        <emphasis>Email</emphasis> objects. For example, the attachments in the provided emails will be
                        ignored since <emphasis>SimpleMailMessage</emphasis> does not support attachments of any kind.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>AysncEmailDispatcher</emphasis> - Sometimes you would like to send the emails in an
                        asynchronous fashion. This dispacher enables exactly that by leveraging Spring's <emphasis>TaskExecutor</emphasis>
                        abstraction. The asynchronous behavior is determined by the configured <emphasis>TaskExecutor</emphasis>.
                        It is also possible to configure a <emphasis>DispatchingErrorHandler</emphasis> to properly handle any
                        error that occur during an email dispatch, and <emphasis>DispatchingCallback</emphasis> that will be
                        called after the email was dispatched (whether successfully or not). By default a
                        <emphasis>LoggingDispatchingErrorHandler</emphasis> and an <emphasis>EmptyDispatchingCallback</emphasis>
                        are set. The logging handler will log any error using Apache Commons Logging logger while the empty
                        callback will do nothing.
                    </para>
                    <para>
                        <note>
                            <para>
                                It is possible to still define a synchronous behaviour using the <emphasis>AsyncEmailDispatcher</emphasis>
                                by configuring a <emphasis>SyncTaskExecutor</emphasis> as the task executor, and for handling the
                                dispatching errors differently a <emphasis>RethrowingDispatchingErrorHandler</emphasis> can be set (which
                                will rethrow all occured errors which might make sense when using the <emphasis>SyncTaskExecutor</emphasis>).
                            </para>
                        </note>
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Here's an example of how the <emphasis>JavaMailEmailDispatcher</emphasis> can be configured in
                an application context:
            </para>

            <programlisting>&lt;bean id="emailDispatcher" class="org.springmodules.email.dispatcher.JavaMailEmailDispatcher"&gt;
    &lt;property name="templateResolver" ref="templateResolver"/&gt;
    &lt;property name="host" value="${mail.host}"/&gt;
    &lt;property name="port" value="${mai.port}"/&gt;

&lt;/bean&gt;

&lt;bean id="templateResolver" class="org.springmodules.template.resolver.SimpleTemplateResolver"&gt;
    &lt;property name="engine" ref="freemarker"/&gt;
    &lt;property name="prefix" value="classpath:/emails/"/&gt;
    &lt;property name="extension" value=".eml"/&gt;
&lt;/bean&gt;

&lt;bean id="freemarker" class="org.springmodules.template.engine.freemarker.FreemarkerTemplateEngine"/&gt;</programlisting>

            <sect3>

                <title>Preparing emails for dispatch</title>

                <para>
                    As mentioned above, one can prepare the email before it is being dispatched by the dispatcher. This
                    can be done by passing an <emphasis>EmailPreparator</emphasis> to the <emphasis>send</emphasis> method.
                    Here is the <emphasis>EmailPreparator</emphasis> interface:
                </para>

                <programlisting>public interface EmailPreparator {

    Email prepare(Email email);

}</programlisting>

                <para>
                    The <emphasis>prepare</emphasis> method accepts the email to prepare (this method will be called by
                    the dispatcher just before sending the email) and returns the prepared email. Alghough, most of the
                    time implementation of this method will return the same email instance that is passed in, it is perfectly
                    possible to return a different email instance (We'll see an example shortly).
                </para>

                <para>
                    There are some preparators that are already implemented which can be used out-of-the-box:
                </para>

                <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>AttachmentEmailPreparator</emphasis> - This preparator enables adding an attachment
                        to an existing email. It can be useful for example when there's a need to attach runtime generated
                        reports to an email (for example PDF reports generated by JasperReports).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>InlineAttachmentEmailPreparator</emphasis> - This preparator enables embedding an attachment
                        in the body of the (html) message. This can be useful for example when there's a need to display
                        an image of a runtime generated graph in the body of the email.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>IdentifiableEmailPreparator</emphasis> - This is an example of a preparator that actually
                        replaces the passed in email with another one. This preparator wraps the passed in email with an
                        IdentifiableEmail and by doing that, associates an id with the email. A scenario where you'd like
                        to do that is when the system keeps all emails in some storage, and an asynchronous dispather is
                        used to send them. When an email is sent it should be removed from the storage. In this case,
                        one can wrap the dispached emails with an IdentifiableEmail where the id represents the
                        identity of the email in the storage. A special <emphasis>DispatchingCallback</emphasis> can then
                        be registered with the async. dispatcher to remove the sent email if the dispatch was successful.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>ChainEmailPreparator</emphasis> - This is a compound email preparator which holds a
                        chain of other email preparators. When asked to prepare an email, this preparator iterates over
                        the preparator chain so that each preparator in the chain prepares the email. This preparator can
                        bue used to easily combine multiple preparators into one.
                    </para>
                </listitem>
            </itemizedlist>

            </sect3>


     </sect2>

    </sect1>

</chapter>