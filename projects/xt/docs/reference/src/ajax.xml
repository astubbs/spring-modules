<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="ajax">
  <title>XT Ajax Framework</title>

  <sect2 id="ajax-intro">
    <title id="ajax-intro-title">Introduction</title>

    <para>XT Ajax Framework is based on the following fundamental
    concepts:</para>

    <itemizedlist>
      <listitem>
        <para>Events</para>
      </listitem>

      <listitem>
        <para>Handlers</para>
      </listitem>

      <listitem>
        <para>Actions</para>
      </listitem>

      <listitem>
        <para>Components</para>
      </listitem>

      <listitem>
        <para>Responses</para>
      </listitem>
    </itemizedlist>

    <para>They work together in a simple processing flow:</para>

    <orderedlist>
      <listitem>
        <para>Web pages fire <emphasis role="bold">events</emphasis> using
        standard <ulink
        url="http://www.w3schools.com/js/js_events.asp"><citetitle>JavaScript
        events</citetitle></ulink>.</para>
      </listitem>

      <listitem>
        <para>Each event causes an Ajax request that is processed by simple
        Java objects acting as server side <emphasis
        role="bold">handlers</emphasis>.</para>
      </listitem>

      <listitem>
        <para>The handler processes events creating <emphasis
        role="bold">actions</emphasis>.</para>
      </listitem>

      <listitem>
        <para>Each action may render one or more HTML <emphasis
        role="bold">components</emphasis> in the page.</para>
      </listitem>

      <listitem>
        <para>At the end, actions are canalised into an Ajax <emphasis
        role="bold">response</emphasis> sent back to the web page.</para>
      </listitem>
    </orderedlist>

    <para>We'll take a more detailed look at each of the concepts above in the
    next section.</para>
  </sect2>

  <sect2 id="ajax-base">
    <title id="ajax-base-title">Base Concepts</title>

    <sect3 id="ajax-events">
      <title id="ajax-events-title">Ajax Events</title>

      <para>In XT Ajax Framework you can raise events from your web pages as
      standard <ulink
      url="http://www.w3schools.com/js/js_events.asp"><citetitle>JavaScript
      events</citetitle></ulink>, and handle them by the server side,
      <emphasis role="bold">without having to write any javascript
      code</emphasis>. There are actually two types of Ajax events:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Action events</emphasis>, a generic
          event type directly handled by configured <link
          linkend="ajax-handlers">handlers</link> <emphasis
          role="bold">without</emphasis> passing control to any Spring MVC
          controller: this is most used for updating the web page with data
          from the server.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Submit events</emphasis>, a special type
          of event handled by configured <link
          linkend="ajax-handlers">handlers</link> <emphasis
          role="bold">after</emphasis> having executed the on submit method of
          the Spring MVC controller associated with the page: this event
          causes the submit of the page and so the handling of the submit by
          the controller, and can be used for further processing the submit in
          order to properly updating the view.</para>
        </listitem>
      </itemizedlist>

      <para>Ajax <emphasis role="bold">action events</emphasis> are basically
      fired in web pages as follows:</para>

      <programlisting>
&lt;input type="button" value="Go" 
    onclick="<emphasis role="bold">XT.doAjaxAction</emphasis>('eventId', this, {'param1' : 'value1', 'param2' : 'value2'});"&gt; 
</programlisting>

      <para>You have to simply call the <emphasis
      role="bold">XT.doAjaxAction</emphasis> JavaScript function,
      passing:</para>

      <itemizedlist>
        <listitem>
          <para>The <emphasis role="bold">name</emphasis> (also called
          <emphasis role="bold">id</emphasis>) of the event you want to fire
          ('eventId' in the snippet above).</para>
        </listitem>

        <listitem>
          <para>The HTML element which fired the event, most of the time
          through the <emphasis role="bold">this</emphasis> objects
          (optional).</para>
        </listitem>

        <listitem>
          <para>A <ulink
          url="http://www.json.org/"><citetitle>JSON</citetitle></ulink>
          string containing extra parameters you want to pass to the server
          (optional).</para>
        </listitem>
      </itemizedlist>

      <warning>
        <para>The old way of executing an Ajax action, through the <emphasis
        role="bold">doAjaxAction</emphasis> JavaScript function, is, starting
        from version 0.8, <emphasis role="bold">no more
        supported</emphasis>.</para>
      </warning>

      <para>Once you receive the event in your server side handler, you can
      access the following information (see XT javadocs for more
      information):</para>

      <itemizedlist>
        <listitem>
          <para>The event id (corresponding to the event name above).</para>
        </listitem>

        <listitem>
          <para>The Java <ulink
          url="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/ServletRequest.html"><citetitle>HttpServletRequest</citetitle></ulink>
          object.</para>
        </listitem>

        <listitem>
          <para>The name and id of the HTML element firing the event.</para>
        </listitem>

        <listitem>
          <para>A map of string key/value pairs, containing the extra
          parameters defined above using the JSON string.</para>
        </listitem>

        <listitem>
          <para>The command object created by the Spring MVC controller, if
          this is a <ulink
          url="http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/web/servlet/mvc/BaseCommandController.html"><citetitle>BaseCommandController</citetitle></ulink>.</para>
        </listitem>
      </itemizedlist>

      <para>Here are the Java interfaces:</para>

      <programlisting>
public interface AjaxEvent {

    public String getEventId();

    public HttpServletRequest getHttpRequest();

    public String getElementName();

    public void setElementName(String elementName);

    public String getElementId();

    public void setElementId(String elementName);

    public Map&lt;String, String&gt; getParameters();

    public void setParameters(Map&lt;String, String&gt; parameters);
}
</programlisting>

      <programlisting>
public interface AjaxActionEvent extends AjaxEvent {

    public Object getCommandObject();

    public void setCommandObject(Object command);
}
</programlisting>

      <para>For firing Ajax <emphasis role="bold">submit events</emphasis>,
      you have to basically write:</para>

      <programlisting>
&lt;input type="button" value="Press" 
    onclick="<emphasis role="bold">XT.doAjaxSubmit</emphasis>('eventId', this {'param1' : 'value1', 'param2' : 'value2'});"&gt; 
</programlisting>

      <para>You have to simply call the <emphasis
      role="bold">XT.doAjaxSubmit</emphasis> JavaScript function, passing it
      the same information defined above.</para>

      <warning>
        <para>The old way of executing an Ajax submit, through the <emphasis
        role="bold">doAjaxSubmit</emphasis> JavaScript function, is, starting
        from version 0.8, <emphasis role="bold">no more
        supported</emphasis>.</para>
      </warning>

      <para>Once you receive the event in your server side handler, you can
      access the following information in addition to those defined above (see
      XT javadocs for more information):</para>

      <itemizedlist>
        <listitem>
          <para>The <ulink
          url="http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/validation/Errors.html"><citetitle>validation
          errors</citetitle></ulink>, for managing form submission errors (if
          any).</para>
        </listitem>

        <listitem>
          <para>The model map returned by the controller submit method (if
          any).</para>
        </listitem>
      </itemizedlist>

      <para>Here are the Java interfaces:</para>

      <programlisting>
public interface AjaxSubmitEvent extends AjaxEvent {

    public Errors getValidationErrors();

    public void setValidationErrors(Errors errors);

    public Object getCommandObject();

    public void setCommandObject(Object command);

    public Map getModel();

    public void setModel(Map model);
}
</programlisting>

      <note>
        <para>Given that submit events are handled after calling the
        configured Spring MVC controller, the command object, model map, and
        validation errors contained in the submit event are <emphasis
        role="bold">the same</emphasis> objects you manage in the
        controller.</para>
      </note>

      <important>
        <para><emphasis>Why are the command object and model map contained
        into the AjaxSubmitEvent null?</emphasis></para>

        <para>This is because your Spring MVC Controller submit method missed
        to return a proper ModelAndView object containing the BindException
        model; for helping that, you are strongly encouraged to construct and
        return an <emphasis role="bold">XTModelAndView</emphasis> object (see
        <emphasis>org.springmodules.web.servlet.XTModelAndView</emphasis>
        javadoc).</para>
      </important>
    </sect3>

    <sect3 id="ajax-handlers">
      <title id="ajax-handlers-title">Ajax Handlers</title>

      <para>The Ajax handler is the server side component to implement for
      processing Ajax events. Here is its interface, followed by a description
      of its methods:</para>

      <programlisting>
public interface AjaxHandler { 

    public boolean supports(AjaxEvent event); 

    public AjaxResponse handle(AjaxEvent event); 
} 
</programlisting>

      <itemizedlist>
        <listitem>
          <para><emphasis>public boolean supports(AjaxEvent event)</emphasis>
          : Check if <emphasis>this</emphasis> handler supports (can handle)
          the given <emphasis role="bold">AjaxEvent</emphasis></para>
        </listitem>

        <listitem>
          <para><emphasis>public AjaxResponse handle(AjaxEvent
          event)</emphasis> : Handle the given <emphasis
          role="bold">AjaxEvent</emphasis> (if supported) and return an
          appropriate <emphasis role="bold">AjaxResponse</emphasis> (see <link
          linkend="ajax-response">Ajax Response</link>).</para>
        </listitem>
      </itemizedlist>

      <para>Out of the box, XT Ajax Framework provides an AjaxHandler abstract
      implementation which provides a straightforward way of implementing Ajax
      handlers: the <emphasis
      role="bold">org.springmodules.xt.ajax.AbstractAjaxHandler</emphasis>.</para>

      <para>AbstractAjaxHandler is an event dispatcher based on Java
      reflection and Ajax events name (<emphasis>id</emphasis>): it implements
      the two methods above by dispatching events to methods named after the
      event id. So, for handling different events, you have to simply
      implement a method named after the event id you want to handle, with the
      following signature:</para>

      <programlisting>
public AjaxResponse eventId(AjaxEvent )
</programlisting>

      <para>Given an ajax event with id <emphasis>countrySelection</emphasis>,
      the handling method will be:</para>

      <programlisting>
public AjaxResponse countrySelection(AjaxEvent )
</programlisting>

      <para>Doing so, you handle generic <emphasis>AjaxEvent</emphasis>s. If
      you want to handle <emphasis>AjaxActionEvent</emphasis>s or
      <emphasis>AjaxSubmitEvent</emphasis>s, simply write methods with the
      following signatures:</para>

      <programlisting>
public AjaxResponse eventId(AjaxActionEvent )
</programlisting>

      <programlisting>
public AjaxResponse eventId(AjaxSubmitEvent )
</programlisting>

      <para>However, you are free to implement a different handling strategy,
      directly implementing the interface above.</para>

      <note>
        <para>When returning from an handler, if you don't want to send any
        response you can safely return a null AjaxResponse. What happens after
        that depends on the kind of event you are handling; see the section:
        <link linkend="ajax-flow">More about the Ajax request processing
        flow</link></para>
      </note>
    </sect3>

    <sect3 id="associating-events-with-handlers">
      <title id="associating-events-with-handlers-title">Associating events
      with handlers: the AjaxInterceptor</title>

      <para>Once defined your events and implemented your handlers, you need
      to <emphasis role="bold">associate</emphasis> them.</para>

      <para>For <emphasis role="bold">security reasons</emphasis>, web page
      events and ajax handlers are not automatically associated, nor can be
      globally associated. If it were so, malicious users could hack your
      JavaScript and execute unwanted events.</para>

      <para>So, events and handlers are associated <emphasis role="bold">per
      page path</emphasis>, that is, you have to configure every handler to
      manage events fired by a pre-determined, restricted, set of pages.
      Specifically, you can configure an handler to manage events fired by a
      specific, single, web page, or by a set of web pages defined with <ulink
      url="http://ant.apache.org"><citetitle>Ant</citetitle></ulink> style
      pattern matching.</para>

      <para>This is done in two simple steps.</para>

      <para>First, you have to define in your Spring application context an
      <emphasis role="bold">AjaxInterceptor</emphasis>: it is the bean which
      associates web pages and Ajax handlers, making under the cover the
      actual event dispatching. Here is an example of AjaxInterceptor
      configuration:</para>

      <programlisting>
&lt;bean id="ajaxInterceptor" class="org.springmodules.xt.ajax.AjaxInterceptor"&gt;

    <emphasis role="bold">&lt;property name="handlerMappings"&gt;
        &lt;props&gt;
            &lt;prop key="/ajax/ex*"&gt;genericAjaxHandler&lt;/prop&gt;
            &lt;prop key="/ajax/ex1.page"&gt;ajaxHandler1&lt;/prop&gt;
            &lt;prop key="/ajax/ex2.page"&gt;ajaxHandler2, ajaxHandler3&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;</emphasis>

&lt;/bean&gt;
</programlisting>

      <para>The <emphasis>handlerMappings</emphasis> property is a list of
      key/value entries associating <emphasis role="bold">a web
      path</emphasis> (the key) <emphasis role="bold">with a comma separated
      list of handlers</emphasis> (the value), which must be declared as beans
      in the Spring application context.As you can notice, the first entry
      associates an handler with an Ant style pattern, the second associates a
      single page with a single handler, the third associates a single page
      with two handlers. So, you can also apply more handlers to the same
      group of pages (or page). When more handlers apply to the same event,
      the one configured for matching the longest web path wins.</para>

      <para>Finally, the second step requires you to associate the
      AjaxInterceptor with the interceptors chain of your Spring MVC <ulink
      url="http://static.springframework.org/spring/docs/1.2.x/api/org/springframework/web/servlet/HandlerMapping.html"><citetitle>URL
      handler mapping</citetitle></ulink>. Here is how:</para>

      <programlisting>
&lt;bean id="urlHandlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;

    <emphasis role="bold">&lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="ajaxInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;</emphasis>

    &lt;property name="mappings"&gt;
        &lt;props&gt;
        &lt;!-- ... --&gt;
        &lt;/props&gt;
    &lt;/property&gt;

&lt;/bean&gt;
</programlisting>
    </sect3>

    <sect3 id="ajax-actions">
      <title id="ajax-actions-title">Ajax Actions</title>

      <para>Ajax actions are created by handlers and act on client web
      pages.</para>

      <para>XT Ajax Framework provides many useful actions ready to be used
      (see the <emphasis>org.springmodules.xt.ajax.action</emphasis> package
      for details); however, creating custom actions is just a matter of
      implementing the following simple interface:</para>

      <programlisting>
public interface AjaxAction { 

    public String execute(); 
} 
</programlisting>

      <para>The <emphasis>execute()</emphasis> method is the one you call for
      producing the action result.</para>

      <para>Most of the actions will act on web pages by rendering components
      and so modifying page parts. But ... how can actions identify page parts
      to modify?</para>
    </sect3>

    <sect3 id="identifying-page-parts">
      <title id="identifying-page-parts-title">Identifying page parts: exact
      and wildcard matching</title>

      <para>Ajax actions identify page parts by the HTML <emphasis
      role="bold"><emphasis role="bold">id</emphasis>
      attribute</emphasis>.</para>

      <para>You have to assign an id to every HTML element you want to
      interact with through Ajax actions:</para>

      <programlisting>
&lt;select id="toFill"&gt;
&lt;/select&gt;
</programlisting>

      <para>All actions that want to modify page contents, have to be created
      with an HTML element id that represent the web page parts that must be
      modified: then, each action can modify one or more elements, depending
      on how many elements the action matches.</para>

      <para>The action can match elements by doing an:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Exact match</emphasis> : the action
          exactly matches the id attribute; an action constructed with a
          "toFill" id to match, exactly matches an element with a "toFill" id
          attribute.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Wildcard match</emphasis> : the action
          matches id attributes ending with the <emphasis role="bold">_
          (underscore)</emphasis> wildcard; an action constructed with a
          "toFill" id to match, matches also an element with a "to_" id
          attribute. Please note that the <emphasis>underscore</emphasis>
          wildcard must be placed in the HTML element id.</para>
        </listitem>
      </itemizedlist>

      <para>Wildcard matching is useful for updating more page parts with the
      same action.</para>

      <programlisting>
&lt;select id="toFill"&gt;
&lt;/select&gt;
</programlisting>

      <programlisting>
&lt;select id="to_"&gt;
&lt;/select&gt;
</programlisting>

      <para>An action constructed with a "toFill" id to match, will actually
      match both elements above.</para>
    </sect3>

    <sect3 id="components">
      <title id="components-title">Components</title>

      <para>Generally speaking, <emphasis role="bold">components</emphasis>
      represent web page parts; more specifically, most of the time they
      represent HTML elements, like input fields, tables and so.</para>

      <para>XT Ajax Framework provides many useful components ready to be
      used:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Static components</emphasis>,
          representing simple, static, HTML elements (see the
          <emphasis>org.springmodules.xt.ajax.component</emphasis> package for
          details).</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Dynamic components</emphasis>, capable
          of dynamically rendering page parts (see the
          <emphasis>org.springmodules.xt.ajax.component.dynamic</emphasis>
          package for details).</para>
        </listitem>
      </itemizedlist>

      <para>However, creating custom components is just a matter of
      implementing the following simple interface:</para>

      <programlisting>
public interface Component { 

    public String render(); 
} 
</programlisting>

      <para>Each component renders itself through the <emphasis
      role="bold">render()</emphasis> method, returning a string
      representation of its rendering.</para>

      <para>But how do actions render components?</para>

      <para>Components are added to actions in a way that depends on the
      concrete action implementation, and then rendered through the action
      <emphasis>execute()</emphasis> method.</para>

      <para>Now that you have your ajax actions and components, the only thing
      left to do is filling your <link linkend="ajax-response">ajax
      response</link>.</para>
    </sect3>

    <sect3 id="ajax-response">
      <title id="ajax-response-title">Ajax Response</title>

      <para><emphasis role="bold">AjaxResponse</emphasis> objects are filled
      with actions whose result is carried to clients, that is, to web pages.
      This is the interface of the AjaxResponse, followed by a description of
      its methods:</para>

      <programlisting>
public interface AjaxResponse { 

    public void addAction(AjaxAction action); 

    public String getResponse(); 

    public boolean isEmpty();
} 
</programlisting>

      <itemizedlist>
        <listitem>
          <para><emphasis>public void addAction(AjaxAction action)</emphasis>
          : This method is used for adding actions that will be executed and
          whose result will be sent to the client.</para>
        </listitem>

        <listitem>
          <para><emphasis>public String getResponse()</emphasis> : This method
          executes the added actions and returns their result.</para>
        </listitem>

        <listitem>
          <para><emphasis>public boolean isEmpty()</emphasis> : This method
          tells if the response has no actions to return.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>In the context of an ajax response, actions are executed
        <emphasis role="bold">following their order of
        adding</emphasis>.</para>
      </note>
    </sect3>

    <sect3 id="ajax-flow">
      <title id="ajax-flow-title">More about the Ajax request processing
      flow</title>

      <para>As seen above, Ajax handlers process events, dispatched by the
      AjaxInterceptor, and return an appropriate AjaxResponse.</para>

      <para>Here is a more schematic, detailed look at the Ajax request
      processing flow.</para>

      <para><emphasis role="bold">On Ajax Action Events :</emphasis></para>

      <orderedlist>
        <listitem>
          <para>The web page fires an ajax action event.</para>
        </listitem>

        <listitem>
          <para>The event is directly dispatched by the AjaxInterceptor toward
          a configured AjaxHandler.</para>
        </listitem>

        <listitem>
          <para>If no handler supporting the event is found, an exception is
          thrown, else if the event is supported by a proper handler, it is
          handled.</para>
        </listitem>

        <listitem>
          <para>After handling, if the handler returns a not null and not
          empty AjaxResponse, it is rendered and the AjaxInterceptor stops the
          execution chain, otherwise the AjaxInterceptor proceed its execution
          chain.</para>
        </listitem>
      </orderedlist>

      <para><emphasis role="bold">On Ajax Submit Events :</emphasis></para>

      <orderedlist>
        <listitem>
          <para>The web page fires an ajax submit event, causing a form
          submit.</para>
        </listitem>

        <listitem>
          <para>The (eventually) configured Spring MVC Controller is
          called.</para>
        </listitem>

        <listitem>
          <para>The Spring MVC Controller handles the form submit, eventually
          calling Validators and making other actions. At the end, it must
          return a ModelAndView with the model contained into the
          BindException object; otherwise, the model and command objects into
          the ajax event object will be null. You can use the <emphasis
          role="bold">XTModelAndView</emphasis> object here (see
          <emphasis>org.springmodules.web.servlet.XTModelAndView</emphasis>
          javadoc).</para>
        </listitem>

        <listitem>
          <para>After the Controller handling, the event is dispatched by the
          AjaxInterceptor toward a configured AjaxHandler.</para>
        </listitem>

        <listitem>
          <para>If no handler supporting the event is found, an exception is
          thrown, else if the event is supported by a proper handler, it is
          handled.</para>
        </listitem>

        <listitem>
          <para>After handling, if the handler returns a not null and not
          empty AjaxResponse, it is rendered; otherwise the AjaxInterceptor
          automatically tries to redirect to the view configured in your
          ModelAndView object. The view must contain the <emphasis
          role="bold">ajax-redirect</emphasis> prefix (i.e. :
          <emphasis>ajax-redirect:/start.page</emphasis>) or the standard
          <emphasis role="bold">redirect</emphasis> prefix (i.e. :
          <emphasis>redirect:/start.page</emphasis>); if the view doesn't
          contain such prefixes, an exception is thrown.</para>
        </listitem>
      </orderedlist>
    </sect3>

    <sect3 id="handling-exceptions">
      <title id="handling-exceptions-title">Handling exceptions</title>

      <para>Spring MVC deals with exceptions occurred during request
      processing by using <ulink
      url="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/web/servlet/HandlerExceptionResolver.html">HandlerExceptionResolver</ulink>s.</para>

      <para>The XT Ajax Framework deals with exceptions occurred during Ajax
      requests in the same way, by using a special HandlerExceptionResolver:
      the <emphasis
      role="bold">org.springmodules.xt.ajax.AjaxExceptionHandlerResolver.
      </emphasis></para>

      <para>It works by mapping exception classes to instances of <emphasis
      role="bold">AjaxExceptionHandler</emphasis> beans (see
      <emphasis>org.springmodules.xt.ajax.AjaxExceptionHandler</emphasis>
      javadoc) configured in the Spring context.</para>

      <para>Here is a sample AjaxExceptionHandlerResolver configuration
      snippet:</para>

      <programlisting>
&lt;bean id="ajaxExceptionResolver" class="<emphasis role="bold">org.springmodules.xt.ajax.AjaxExceptionHandlerResolver</emphasis>"&gt;
    &lt;property name="exceptionMappings"&gt;
        &lt;map&gt;
            <emphasis role="bold">&lt;entry key="java.lang.Exception" value-ref="exceptionHandler"/&gt;</emphasis>
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>

      <para>The AjaxExceptionHandler bean then takes care of resolving the
      exception to an AjaxResponse to send to clients. Here is its
      interface:</para>

      <programlisting>
public interface AjaxExceptionHandler {

    public AjaxResponse handle(HttpServletRequest request, Exception ex);
}
</programlisting>

      <para>Out of the box, XT Ajax Framework provides the <emphasis
      role="bold">RedirectExceptionHandler</emphasis> (see
      <emphasis>org.springmodules.xt.ajax.support.RedirectExceptionHandler</emphasis>
      javadoc), an AjaxExceptionHandler implementation for redirecting to a
      given error page. Here is a sample configuration snippet:</para>

      <programlisting>
&lt;bean id="exceptionHandler" class="<emphasis role="bold">org.springmodules.xt.ajax.support.RedirectExceptionHandler</emphasis>"&gt;
    &lt;property name="redirectUrl" value="/error.page"/&gt;
    &lt;property name="exceptionMessageAttribute" value="exceptionMessage"/&gt;
&lt;/bean&gt;
</programlisting>

      <warning>
        <para>Starting from 0.9 version, the old
        org.springmodules.xt.ajax.AjaxExceptionHandler is now called
        org.springmodules.xt.ajax.AjaxExceptionHandlerResolver, while the old
        org.springmodules.xt.ajax.AjaxExceptionResolver and
        org.springmodules.xt.ajax.support.RedirectExceptionResolver are
        respectively called org.springmodules.xt.ajax.AjaxExceptionHandler and
        org.springmodules.xt.ajax.support.RedirectExceptionHandler.</para>
      </warning>
    </sect3>
  </sect2>

  <sect2>
    <title>Advanced Concepts</title>

    <sect3>
      <title>Core Javascript libraries</title>

      <para>The client side API of the XT Ajax Framework is based on the
      <ulink
      url="http://taconite.sourceforge.net"><citetitle>Taconite</citetitle></ulink>
      and <ulink
      url="http://www.json.org/js.html"><citetitle>JSON</citetitle></ulink>
      JavaScript libraries, plus some other JavaScript stuff.</para>

      <para>These are the core XT Ajax Javascript libraries: you can find them
      under the <emphasis>js</emphasis> directory.</para>

      <para>They are put, at compile time, in the <emphasis
      role="bold">springxt.js</emphasis> file under the
      <emphasis>js/lib/core</emphasis> directory. This is the only <emphasis
      role="bold">mandatory</emphasis> file you need to include in your web
      page:</para>

      <programlisting>
&lt;script type="text/javascript" src='springxt.js'&gt;&lt;/script&gt; 
</programlisting>

      <tip>
        <para>Under the <emphasis>js/lib/core</emphasis> you'll find also a
        <emphasis role="bold">springxt-min.js</emphasis> file: it is a
        minified version of <emphasis>springxt.js</emphasis> you can include
        in your pages for reducing the download size.</para>
      </tip>
    </sect3>

    <sect3>
      <title>Optional Javascript libraries</title>

      <para>XT Ajax Framework integrates with a number of other Javascript
      libraries, in order to provide additional Ajax functionalities:</para>

      <itemizedlist>
        <listitem>
          <para><ulink
          url="http://prototype.conio.net/"><citetitle>Prototype</citetitle></ulink>
          (version 1.5.0 rc1 or higher) : see javadocs for the
          <emphasis>org.springmodules.xt.ajax.action.prototype</emphasis>
          classes.</para>
        </listitem>

        <listitem>
          <para><ulink
          url="http://script.aculo.us/"><citetitle>Script.aculo.us</citetitle></ulink>
          (version 1.6.4 or higher) : see javadocs for the
          <emphasis>org.springmodules.xt.ajax.action.prototype.scriptaculous</emphasis>
          classes.</para>
        </listitem>
      </itemizedlist>
    </sect3>
  </sect2>

  <sect2 id="ajax-tutorials">
    <title id="ajax-tutorials-title">Tutorials</title>

    <para>In this section we'll show you, by practical, step-by-step
    tutorials, how to work with XT Ajax Framework. All tutorials are based on
    XT Ajax samples: take a look at the samples provided with the main
    distribution or <ulink
    url="https://springmodules.dev.java.net/source/browse/springmodules/samples/xt/"><citetitle>check
    out them</citetitle></ulink> if you want to take a look at the full source
    code.</para>

    <sect3 id="ajax-tutorial-1">
      <title id="ajax-tutorial-1-title">Working with Ajax action
      events.</title>

      <para>Ajax action events are used for updating pages without submitting
      data to (eventually configured) Spring MVC controllers: so, <emphasis
      role="bold">the execution of an Ajax action event doesn't call
      controllers</emphasis>.</para>

      <para>In this tutorial we'll implement a simple Ajax sample that let you
      <emphasis role="bold">fill a selection box with a list of Office names
      after clicking a button</emphasis>, showing you how to:</para>

      <itemizedlist>
        <listitem>
          <para>Write the web page.</para>
        </listitem>

        <listitem>
          <para>Write the Ajax handler.</para>
        </listitem>

        <listitem>
          <para>Map the Ajax handler to the web page URL.</para>
        </listitem>
      </itemizedlist>

      <sect4 id="ajax-tutorial-1-step-1">
        <title>Step 1 : Writing the web page.</title>

        <para>Writing a web page that fires an Ajax action event is not
        different than writing a normal JSP based web page as you'd usually
        do.</para>

        <para>First, import the core XT Ajax javascript library:</para>

        <programlisting>
&lt;script type="text/javascript" src='<emphasis role="bold">springxt.js</emphasis>'&gt;&lt;/script&gt;
</programlisting>

        <para>Our web page must fill the selection list after clicking a
        button. So, write a button input field that fires an Ajax action event
        with <emphasis>loadOffices</emphasis> as event id:</para>

        <programlisting>
&lt;input type="button" value="Press" onclick="<emphasis role="bold">XT.doAjaxAction('loadOffices', this);</emphasis>"&gt; 
</programlisting>

        <para>Then, write the <emphasis>select</emphasis> HTML element to
        update and give it an id:</para>

        <programlisting>
&lt;select id="<emphasis role="bold">offices</emphasis>"&gt;
    &lt;option&gt;--- ---&lt;/option&gt;
&lt;/select&gt;
</programlisting>

        <para>Recall that the <emphasis>id</emphasis> attribute is used for
        identifying the page part to update, that is, the element to fill with
        new content.</para>

        <para>That's all ... let's write our Ajax handler!</para>
      </sect4>

      <sect4 id="ajax-tutorial-1-step-2">
        <title>Step 2 : Writing the Ajax handler.</title>

        <para>Our Ajax handler will extend the
        <emphasis>org.springmodules.xt.ajax.AbstractAjaxHandler</emphasis>, so
        it will have a method called after the Ajax event to handle, that will
        accept an
        <emphasis>org.springmodules.xt.ajax.AjaxActionEvent</emphasis>:</para>

        <programlisting>
public AjaxResponse <emphasis role="bold">loadOffices</emphasis>(AjaxActionEvent event)
</programlisting>

        <para>Now, let us analyze how to handle the event, by implementing the
        <emphasis>loadOffices</emphasis> method above.</para>

        <para>First, we have to retrieve a list of offices from some kind of
        data access object:</para>

        <programlisting>
Collection&lt;IOffice&gt; offices = store.getOffices();
</programlisting>

        <para>Then, we have to create the components to render: a list of
        <emphasis>org.springmodules.xt.ajax.component.Option</emphasis>
        components, representing the <emphasis>option</emphasis> HTML elements
        and containing the office id as value and the office name as
        content.</para>

        <programlisting>
// <emphasis role="bold">Create the options list:</emphasis>
List options = new LinkedList();
// <emphasis role="bold">The first option is just a dummy one:</emphasis>
Option first = new Option("-1", "Select one ...");
options.add(first);
// <emphasis role="bold">Create options representing offices:</emphasis>
for(IOffice office : offices) {
    Option option = new Option(office, "officeId", "name");
    options.add(option);
}
</programlisting>

        <para>Now, we have to replace the HTML content of the
        <emphasis>select</emphasis> element showed above, so we have to create
        an
        <emphasis>org.springmodules.xt.ajax.action.ReplaceContentAction</emphasis>,
        adding it the components to render (the list of options):</para>

        <programlisting>
ReplaceContentAction <emphasis role="bold">action</emphasis> = new ReplaceContentAction("<emphasis
            role="bold">offices</emphasis>", options);
</programlisting>

        <para>Note that the <emphasis>ReplaceContentAction</emphasis> updates
        the HTML element with <emphasis>offices</emphasis> as id.</para>

        <para>Finally, we create an
        <emphasis>org.springmodules.xt.ajax.AjaxResponse</emphasis>, add the
        action and return it!</para>

        <programlisting>
AjaxResponse response = new AjaxResponseImpl();
response.addAction(<emphasis role="bold">action</emphasis>);
return response;
</programlisting>

        <para>That's the simple implementation of the
        <emphasis>loadOffices</emphasis> method!</para>
      </sect4>

      <sect4 id="ajax-tutorial-1-step-3">
        <title>Step 3 : Mapping the Ajax handler to the web page URL.</title>

        <para>Say the web page URL is:
        <emphasis>www.example.org/xt/ajax/tutorial1.page</emphasis>. Mapping
        the Ajax handler is simply a matter of configuring the Ajax handler
        bean (<emphasis>LoadOfficesHandler</emphasis> in the snippet below) in
        the Spring application context and mapping it in the
        <emphasis>AjaxInterceptor</emphasis>:</para>

        <programlisting>
&lt;bean id="<emphasis role="bold">ajaxLoadOfficesHandler</emphasis>" class="org.springmodules.xt.examples.ajax.LoadOfficesHandler"&gt;
    &lt;property name="store" ref="store"/&gt;
&lt;/bean&gt;
</programlisting>

        <programlisting>
&lt;bean id="ajaxInterceptor" class="org.springmodules.xt.ajax.AjaxInterceptor"&gt;
    &lt;property name="handlerMappings"&gt;
        &lt;props&gt;
            <emphasis role="bold">&lt;prop key="/ajax/tutorial1.page"&gt;ajaxLoadOfficesHandler&lt;/prop&gt;</emphasis>
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>
      </sect4>
    </sect3>

    <sect3 id="ajax-tutorial-2">
      <title id="ajax-tutorial-2-title">Working with Ajax submit
      events.</title>

      <para>Ajax submit events are used for updating pages <emphasis
      role="bold">after</emphasis> submitting data to your Spring MVC
      controllers.</para>

      <para>In this tutorial we'll implement a simple Ajax sample that let you
      <emphasis role="bold">choose an office and list its employees in a table
      after submitting the form by clicking a button</emphasis>. We'll see how
      to:</para>

      <itemizedlist>
        <listitem>
          <para>Write the web page.</para>
        </listitem>

        <listitem>
          <para>Write the Spring MVC controller.</para>
        </listitem>

        <listitem>
          <para>Write the Ajax handler.</para>
        </listitem>

        <listitem>
          <para>Map the Ajax handler to the web page URL.</para>
        </listitem>
      </itemizedlist>

      <sect4 id="ajax-tutorial-2-step-1">
        <title>Step 1 : Writing the web page.</title>

        <para>Writing a web page that fires a submit event is not different
        than writing a normal JSP based web page as you'd usually do.</para>

        <para>First, import the core XT Ajax javascript library:</para>

        <programlisting>
&lt;script type="text/javascript" src='<emphasis role="bold">springxt.js</emphasis>'&gt;&lt;/script&gt;
</programlisting>

        <para>Employees are listed in an HTML table after clicking a button.
        So, you have to write a button input field that fires an Ajax submit
        event with <emphasis>listEmployees</emphasis> as event id:</para>

        <programlisting>
&lt;input type="button" value="List" onclick="<emphasis role="bold">XT.doAjaxSubmit('listEmployees', this);</emphasis>"&gt; 
</programlisting>

        <para>Then, write the HTML <emphasis>table</emphasis> element to use
        for listing the employees:</para>

        <programlisting>
&lt;table border="1"&gt;

    &lt;thead&gt;
       &lt;tr&gt;
           &lt;th&gt;Firstname&lt;/th&gt;
           &lt;th&gt;Surname&lt;/th&gt;
           &lt;th&gt;Matriculation Code&lt;/th&gt;
       &lt;/tr&gt;
    &lt;/thead&gt;

   &lt;tbody id="<emphasis role="bold">employees</emphasis>"&gt;
   &lt;/tbody&gt;

&lt;/table&gt;
</programlisting>

        <para>Please note the table body, with an
        <emphasis>employees</emphasis> id attribute: this is the page part
        that will be updated with the employees list.</para>

        <para>That's all ... let's take a look at our Spring MVC
        controller!</para>
      </sect4>

      <sect4 id="ajax-tutorial-2-step-2">
        <title>Step 2 : Writing the Spring MVC controller.</title>

        <para>XT Ajax Framework requires only little changes to the way you
        write Spring MVC controllers.</para>

        <para>For the purposes of our example, the most interesting part of
        our Spring MVC controller is the <emphasis>onSubmit</emphasis>
        method:</para>

        <programlisting>
protected ModelAndView onSubmit(Object command, BindException errors) 
throws Exception {
    // <emphasis role="bold">Take the command object and the office contained in it:</emphasis>
    EmployeesListForm form = (EmployeesListForm) command;
    Office office = form.getOffice();

    // <emphasis role="bold">Take a list of employees by office:</emphasis>
    Collection&lt;IEmployee&gt; employees = store.getEmployeesByOffice(office);

    // <emphasis role="bold">Construct and return the ModelAndView:</emphasis>
    Map model = new HashMap(1);
    model.put("employees", employees);
    return new XTModelAndView(this.getSuccessView(), errors, model);
    // <emphasis role="bold">The model map contains the employee list that will be rendered using ajax!</emphasis>
}
</programlisting>

        <para>The only difference is the use of the <emphasis
        role="bold">XTModelAndView</emphasis> (see
        <emphasis>org.springmodules.web.servlet.XTModelAndView</emphasis>
        javadoc), carrying the BindException errors object required by the
        Ajax framework.</para>

        <note>
          <para>The XTModelAndView object behaves exactly the same as a
          standard ModelAndView object.</para>
        </note>

        <para>Let's go with our Ajax handler!</para>
      </sect4>

      <sect4 id="ajax-tutorial-2-step-3">
        <title>Step 3 : Writing the Ajax handler.</title>

        <para>Our Ajax handler will extend the
        <emphasis>org.springmodules.xt.ajax.AbstractAjaxHandler</emphasis>, so
        it will have a method called after the Ajax event to handle, that will
        accept an
        <emphasis>org.springmodules.xt.ajax.AjaxSubmitEvent</emphasis>:</para>

        <programlisting>
public AjaxResponse <emphasis role="bold">listEmployees</emphasis>(AjaxSubmitEvent event)
</programlisting>

        <para>Let's talk about the <emphasis>listEmployees</emphasis> method
        implementation.</para>

        <para>We want to show the employees belonging to the selcted office,
        so we have to retrieve the model map from the event object, and the
        employee list contained in it:</para>

        <programlisting>
Map model = event.getModel();
Collection&lt;IEmployee&gt; employees = (Collection) model.get("employees");
</programlisting>

        <para>Then, we have to create the components to render: a list of
        <emphasis>org.springmodules.xt.ajax.component.TableRow</emphasis>
        components, containing the employees:</para>

        <programlisting>
// <emphasis role="bold">Create the rows list:</emphasis>
List rows = new LinkedList();
for(IEmployee emp : employees) {
    // <emphasis role="bold">Every row is an employee:</emphasis>
    TableRow row = new TableRow(emp, new String[]{"firstname", "surname", "matriculationCode"}, null);
    rows.add(row);
}
</programlisting>

        <para>Now we have to replace all the rows in the HTML table, so we
        have to create an
        <emphasis>org.springmodules.xt.ajax.action.ReplaceContentAction</emphasis>,
        adding it the components to render:</para>

        <programlisting>
ReplaceContentAction <emphasis role="bold">action</emphasis> = new ReplaceContentAction("<emphasis
            role="bold">employees</emphasis>", rows);
</programlisting>

        <para>Note that the <emphasis>ReplaceContentAction</emphasis> updates
        the HTML element with <emphasis>employees</emphasis> as id.</para>

        <para>Finally, we have to create an
        <emphasis>org.springmodules.xt.ajax.AjaxResponse</emphasis> and return
        it!</para>

        <programlisting>
AjaxResponse response = new AjaxResponseImpl();
response.addAction(<emphasis role="bold">action</emphasis>);
return response;
</programlisting>

        <para>That's the <emphasis>listEmployees</emphasis> method
        implementation!</para>
      </sect4>

      <sect4 id="ajax-tutorial-2-step-4">
        <title>Step 4 : Mapping the Ajax handler to the web page URL.</title>

        <para>Say the web page URL is:
        <emphasis>www.example.org/xt/ajax/tutorial2.page</emphasis>. Mapping
        the Ajax handler is simply a matter of configuring the Ajax handler
        bean (<emphasis>ajaxListEmployeesHandler</emphasis> in the snippet
        below) in the Spring application context and mapping it in the
        <emphasis>AjaxInterceptor</emphasis>:</para>

        <programlisting>
&lt;bean id="<emphasis role="bold">ajaxListEmployeesHandler</emphasis>" class="org.springmodules.xt.examples.ajax.ListEmployeesHandler"&gt;
    &lt;property name="store" ref="store"/&gt;
&lt;/bean&gt;
</programlisting>

        <programlisting>
&lt;bean id="ajaxInterceptor" class="org.springmodules.xt.ajax.AjaxInterceptor"&gt;
    &lt;property name="handlerMappings"&gt;
        &lt;props&gt;
            <emphasis role="bold">&lt;prop key="/ajax/tutorial2.page"&gt;ajaxListEmployeesHandler&lt;/prop&gt;</emphasis>
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>
      </sect4>
    </sect3>

    <sect3 id="ajax-tutorial-3">
      <title id="ajax-tutorial-3-title">Working with Ajax validation.</title>

      <para>Ajax validation is a common use case, so the XT Ajax Framework
      provides the <emphasis
      role="bold">org.springmodules.xt.ajax.validation.DefaultValidationHandler</emphasis>
      for doing Ajax based validation in a very simple way.</para>

      <para>In this tutorial we'll implement a simple Ajax validation use
      case, <emphasis role="bold">validating an employee matriculation
      code</emphasis>. We'll see how to:</para>

      <itemizedlist>
        <listitem>
          <para>Use the DefaultValidationHandler.</para>
        </listitem>

        <listitem>
          <para>Write the Spring MVC validator.</para>
        </listitem>

        <listitem>
          <para>Write the web page.</para>
        </listitem>
      </itemizedlist>

      <sect4 id="ajax-tutorial-3-step-1">
        <title>Step 1 : Using the DefaultValidationHandler.</title>

        <para>If you want to use the DefaultValidationHandler without any
        customization, you must simply configure and map it into the Spring
        application context as you'd usually do with any other handler:</para>

        <para><programlisting>
&lt;bean id="<emphasis role="bold">ajaxValidationHandler</emphasis>" class="org.springmodules.xt.ajax.validation.DefaultValidationHandler"&gt;</programlisting><programlisting>
&lt;bean id="ajaxInterceptor" class="org.springmodules.xt.ajax.AjaxInterceptor"&gt;
    &lt;property name="handlerMappings"&gt;
        &lt;props&gt;
            <emphasis role="bold">&lt;prop key="/ajax/tutorial3.page"&gt;ajaxValidationHandler&lt;/prop&gt;</emphasis>
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting></para>

        <para>By default, the DefaultValidationHandler displays and highlights
        error messages in the submitted web page, and redirects to the success
        page on successfull.</para>

        <note>
          <para>You can <emphasis role="bold">customize how error messages are
          rendered</emphasis>, by providing a custom implementation of the
          <emphasis
          role="bold">org.springmodules.xt.ajax.validation.ErrorRenderingCallback</emphasis>
          class, and <emphasis role="bold">how successfull validation is
          handled</emphasis>, by providing a custom implementation of the
          <emphasis
          role="bold">org.springmodules.xt.ajax.validation.SuccessRenderingCallback</emphasis>
          class.</para>
        </note>
      </sect4>

      <sect4 id="ajax-tutorial-3-step-2">
        <title>Step 2 : Writing the Spring MVC validator.</title>

        <para>XT Ajax Framework doesn't require to change the validator code:
        it is completely independent.</para>

        <para>So here is the validator:</para>

        <programlisting>
public class EmployeeValidator implements Validator {

    public boolean supports(Class aClass) {
        return IEmployee.class.isAssignableFrom(aClass);
    }

    public void validate(Object object, Errors errors) {
        if (this.supports(object.getClass())) {
            IEmployee emp = (IEmployee) object;
            if (emp.getMatriculationCode() == null || emp.getMatriculationCode().equals("")) {
                errors.rejectValue("matriculationCode", 
                "<emphasis role="bold">employee.null.code</emphasis>", "No Matriculation Code!");
            }
        }
    }
}</programlisting>

        <para>The <emphasis>employee.null.code</emphasis> is the error code
        whose message will be rendered in the web page.</para>
      </sect4>

      <sect4 id="ajax-tutorial-3-step-3">
        <title>Step 3 : Writing the web page.</title>

        <para>First, import the core XT Ajax javascript library, plus the
        Prototype and Script.aculo.us libraries:</para>

        <programlisting>
&lt;script type="text/javascript" src='<emphasis role="bold">springxt.js</emphasis>'&gt;&lt;/script&gt;
&lt;script type="text/javascript" src='<emphasis role="bold">prototype.js</emphasis>'&gt;&lt;/script&gt;
&lt;script type="text/javascript" src='<emphasis role="bold">scriptaculous.js?load=effects</emphasis>'&gt;&lt;/script&gt;
</programlisting>

        <para>Then, you have to mark the HTML elements where to show the
        errors sent by the validator: this requires only to <emphasis
        role="bold">write HTML elements whose id is the same as the error
        codes you want to show</emphasis>.</para>

        <para>In our sample, we have an
        <emphasis>employee.null.code</emphasis> error code, and we want to
        have a <emphasis>div</emphasis> element containing all employee
        related errors, and another one containing just the
        <emphasis>employee.null.code</emphasis> error; here is what we have to
        write:</para>

        <programlisting>
&lt;div id="<emphasis role="bold">employee._</emphasis>"/&gt;
......
&lt;div id="<emphasis role="bold">employee.null.code</emphasis>"/&gt;
</programlisting>

        <para>The DefaultValidationHandler will use <emphasis
        role="bold">exact and wildcard matching</emphasis> for filling the
        elements above with proper error messages.</para>

        <note>
          <para>Error messages filled by the DefaultValidationHandler are
          <emphasis role="bold">internationalized</emphasis>.</para>
        </note>

        <para>Finally, you have to simply call the DefaultValidationHandler by
        firing an Ajax submit event in the following way:</para>

        <programlisting>
&lt;input type="button" value="Fire" onclick="<emphasis role="bold">XT.doAjaxSubmit('validate', this);</emphasis>"&gt;
</programlisting>

        <note>
          <para><emphasis>validate</emphasis> is the mandatory event name
          associated with the DefaultValidationHandler.</para>
        </note>
      </sect4>
    </sect3>
  </sect2>
</sect1>