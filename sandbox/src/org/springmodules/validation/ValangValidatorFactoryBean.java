package org.springmodules.validation;import java.io.StringReader;import java.util.Collection;import java.util.Map;import java.util.Iterator;import org.springframework.beans.BeanWrapper;import org.springframework.beans.BeanWrapperImpl;import org.springframework.beans.factory.FactoryBean;import org.springframework.beans.factory.InitializingBean;import org.springframework.util.StringUtils;import org.springframework.validation.Errors;import org.springframework.validation.Validator;import org.springmodules.util.dateparser.DefaultDateParser;import org.springmodules.validation.predicates.ValidationRule;import org.springmodules.validation.valang.ParseException;import org.springmodules.validation.valang.ValangParser;import org.springmodules.validation.valang.ValangVisitor;/** * <p>ValangValidatorFactoryBean takes a Valang syntax and returns a * org.springframework.validation.Validator instance. This instance is * a singleton and is thread-safe. *  * <p>The syntax of a Valang instruction is: *  * <pre> * { &lt;key&gt; : &lt;expression&gt; : &lt;error_message&gt; } * </pre> *  * <p>These instructions can be repeated and will be combined in a Validator instance. * Each instruction will execute the expression on a target bean. If the expression fails * the key will be rejected with the error message. *  * <p>Some examples of the Valang syntax: *  * <pre> * 	&lt;bean id="myValidator" class="org.springmodules.validation.ValangValidatorFactoryBean"&gt; * 		&lt;property name="valang"&gt;&lt;value&gt;&lt;![CDATA[ * 		{ age : age is not null : 'Age is a required field.' } * 		{ age : age is null or age &gt;= 18 : 'Customers must be 18 years or older.' } * 		{ valueDate : valueDate is not null : 'Value date is a required field.' } * 		{ valueDate : valueDate is null or (valueDate >= [T&lt;d] and [T&gt;d] > valueDate) : * 				'Value date must be today.' } * 		{ firstName : firstName has text : 'First name is a required field.' } * 		{ firstName : firstName has no text or length(firstName) &lt;= 50 :  * 				'First name must be no longer than 50 characters.' } * 		{ size : size has length : 'Size is a required field.' } * 		{ size : size has no length or upper(size) in 'S', 'M', 'L', 'XL' : * 				'Size must be either S, M, L or XL.' } * 		{ lastName : lastName has text and !(false) = true : * 				'Last name is required and not false must be true.' } * 		]]&gt;&lt;/value&gt;&lt;/property&gt; * 	&lt;/bean&gt; * </pre> *  * <p>Custom property editors can be registered using * org.springmodules.validation.CustomPropertyEditor. *  * <p>A custom visitor can be registered to use custom functions in the Valang * syntax. *  * @author Steven Devijver * @since 23-04-2005 * @see org.springmodules.util.dateparser.DefaultDateParser * @see org.springframework.validation.Validator */public class ValangValidatorFactoryBean		implements			FactoryBean,			InitializingBean {	private String valang = null;	private Validator validator = null;	private ValangVisitor visitor = null;	private Collection customPropertyEditors = null;	private Map dateParserRegistrations = null;		public ValangValidatorFactoryBean() {		super();	}	/**	 * 	 * <p>	 * This property sets the Valang syntax.	 * 	 * 	 * 	 * @param valang	 *            the Valang syntax	 *  	 */	public void setValang(String valang) {		this.valang = valang;	}	/**	 * 	 * <p>	 * This property takes a custom visitor with custom functions.	 * 	 * 	 * 	 * @param visitor	 *            the custom visitor;	 * @see org.springmodules.validation.valang.DefaultVisitor#setVisitor(ValangVisitor) 	 */	public void setVisitor(ValangVisitor visitor) {		this.visitor = visitor;	}	/**	 * 	 * <p>	 * Sets custom property editors on BeanWrapper instances (optional).	 * 	 * 	 * 	 * @param customPropertyEditors	 *            the custom editors.	 * @see BeanWrapper#registerCustomEditor(java.lang.Class, java.lang.String, java.beans.PropertyEditor)	 * @see BeanWrapper#registerCustomEditor(java.lang.Class, java.beans.PropertyEditor)	 *  	 */	public void setCustomPropertyEditors(Collection customPropertyEditors) {		this.customPropertyEditors = customPropertyEditors;	}	/**	 * <p>Sets date parser registrations (formats and modifiers) on DefaultDateParser (optional).	 * 	 * @param dateParserRegistrations the date parser registrations	 * @see org.springmodules.util.dateparser.DefaultDateParser#register(String, String)	 * @see org.springmodules.util.dateparser.DefaultDateParser#register(String, DateModifier)	 */	public void setDateParserRegistrations(Map dateParserRegistrations) {		this.dateParserRegistrations = dateParserRegistrations;	}		private Map getDateParserRegistrations() {		return this.dateParserRegistrations;	}		private Collection getCustomPropertyEditors() {		return this.customPropertyEditors;	}	private String getValang() {		return this.valang;	}	public Object getObject() throws Exception {		return this.validator;	}	public Class getObjectType() {		return Validator.class;	}	public boolean isSingleton() {		return true;	}	public void afterPropertiesSet() throws Exception {		if (!StringUtils.hasLength(getValang())) {			throw new IllegalArgumentException("[valang] property must be set!");		}		this.validator = new Validator() {			private Collection rules = null;			{				try {					ValangParser parser = new ValangParser(new StringReader(							getValang()));					parser.getVisitor().setVisitor(visitor);					if (getDateParserRegistrations() != null) {						for (Iterator iter = getDateParserRegistrations().keySet().iterator(); iter.hasNext();) {							String regexp = (String)iter.next();							Object value = getDateParserRegistrations().get(regexp);														if (value instanceof String) {								parser.getVisitor().getDateParser().register(regexp, (String)value);							} else if (value instanceof DefaultDateParser.DateModifier) {								parser.getVisitor().getDateParser().register(regexp, (DefaultDateParser.DateModifier)value);							} else {								throw new ClassCastException("Could not register instance [" + value + "] with date parser!");							}						}					}										rules = parser.parseValidation();				} catch (ParseException e) {					throw new RuntimeException(e);				}			}			public boolean supports(Class clazz) {				return true;			}			public void validate(Object target, Errors errors) {				BeanWrapper beanWrapper = null;				if (target instanceof BeanWrapper) {					beanWrapper = (BeanWrapper) target;				} else {					beanWrapper = new BeanWrapperImpl(target);				}				if (getCustomPropertyEditors() != null) {					for (Iterator iter = getCustomPropertyEditors().iterator(); iter							.hasNext();) {						CustomPropertyEditor customPropertyEditor = (CustomPropertyEditor) iter								.next();						if (customPropertyEditor.getRequiredType() == null) {							throw new IllegalArgumentException(									"[requiredType] is required on CustomPropertyEditor instances!");						} else if (customPropertyEditor.getPropertyEditor() == null) {							throw new IllegalArgumentException(									"[propertyEditor] is required on CustomPropertyEditor instances!");						}						if (StringUtils.hasLength(customPropertyEditor								.getPropertyPath())) {							beanWrapper.registerCustomEditor(									customPropertyEditor.getRequiredType(),									customPropertyEditor.getPropertyPath(),									customPropertyEditor.getPropertyEditor());						} else {							beanWrapper.registerCustomEditor(									customPropertyEditor.getRequiredType(),									customPropertyEditor.getPropertyEditor());						}					}				}				for (Iterator iter = rules.iterator(); iter.hasNext();) {					ValidationRule rule = (ValidationRule) iter.next();					rule.validate(beanWrapper, errors);				}			}		};	}}