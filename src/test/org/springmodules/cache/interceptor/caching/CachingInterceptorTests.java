/* 
 * Created on Sep 24, 2004
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * Copyright @2004 the original author or authors.
 */

package org.springmodules.cache.interceptor.caching;

import java.io.Serializable;
import java.lang.reflect.Method;

import junit.framework.TestCase;

import org.aopalliance.intercept.MethodInvocation;
import org.easymock.MockControl;
import org.springmodules.cache.key.CacheKeyGenerator;
import org.springmodules.cache.key.HashCodeCacheKeyGenerator;
import org.springmodules.cache.provider.CacheProviderFacade;

/**
 * <p>
 * Unit Tests for <code>{@link CachingInterceptor}</code>.
 * </p>
 * 
 * @author Alex Ruiz
 * 
 * @version $Revision: 1.4 $ $Date: 2005/08/05 02:45:15 $
 */
public final class CachingInterceptorTests extends TestCase {

  /**
   * Key to be generated by <code>{@link #cacheKeyGenerator}</code>.
   */
  private Serializable cacheKey;

  private CacheKeyGenerator cacheKeyGenerator;

  private MockControl cacheKeyGeneratorControl;

  private CacheProviderFacade cacheProviderFacade;

  private MockControl cacheProviderFacadeControl;

  /**
   * Metadata attribute for the intercepted method.
   */
  private Cached cachingAttribute;

  private CachingAttributeSource cachingAttributeSource;

  private MockControl cachingAttributeSourceControl;

  /**
   * Primary object that is under test.
   */
  private CachingInterceptor cachingInterceptor;

  private EntryStoredListener entryStoredListener;

  private MockControl entryStoredListenerControl;

  /**
   * Method to be intercepted by <code>{@link #cachingInterceptor}</code>.
   */
  private Method interceptedMethod;

  private MethodInvocation methodInvocation;

  private MockControl methodInvocationControl;

  public CachingInterceptorTests(String name) {
    super(name);
  }

  protected void setUp() throws Exception {
    super.setUp();

    Class targetClass = String.class;
    this.interceptedMethod = targetClass.getMethod("concat",
        new Class[] { String.class });

    this.cacheProviderFacadeControl = MockControl
        .createControl(CacheProviderFacade.class);
    this.cacheProviderFacade = (CacheProviderFacade) this.cacheProviderFacadeControl
        .getMock();

    this.cachingAttribute = new Cached();
    this.cachingAttribute.setCacheProfileId("CACHE_PROFILE");

    this.cachingAttributeSourceControl = MockControl
        .createControl(CachingAttributeSource.class);
    this.cachingAttributeSource = (CachingAttributeSource) this.cachingAttributeSourceControl
        .getMock();

    this.methodInvocationControl = MockControl
        .createControl(MethodInvocation.class);
    this.methodInvocation = (MethodInvocation) this.methodInvocationControl
        .getMock();

    this.cachingInterceptor = new CachingInterceptor();
    this.cachingInterceptor.setCacheProviderFacade(this.cacheProviderFacade);
    this.cachingInterceptor
        .setCachingAttributeSource(this.cachingAttributeSource);

    this.setUpCommonMockControlExpectations();
  }

  private void setUpCacheKey() {
    this.cacheKey = "Key";
  }

  private void setUpCommonMockControlExpectations() {
    this.methodInvocation.getMethod();
    this.methodInvocationControl.setReturnValue(this.interceptedMethod);
  }

  private void setUpCacheKeyGeneratorAsMockObject() {
    this.cacheKeyGeneratorControl = MockControl
        .createControl(CacheKeyGenerator.class);
    this.cacheKeyGenerator = (CacheKeyGenerator) this.cacheKeyGeneratorControl
        .getMock();
    this.cachingInterceptor.setCacheKeyGenerator(this.cacheKeyGenerator);
  }

  private void setUpEntryStoredListenerAsMockObject() {
    this.entryStoredListenerControl = MockControl
        .createControl(EntryStoredListener.class);
    this.entryStoredListener = (EntryStoredListener) this.entryStoredListenerControl
        .getMock();
    this.cachingInterceptor.setEntryStoredListener(this.entryStoredListener);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#afterPropertiesSet()}</code> assigns a
   * new instance of <code>{@link HashCodeCacheKeyGenerator}</code> as the key
   * generator of the interceptor if the interceptor does not have a cache
   * generator already set.
   */
  public void testAfterPropertiesSetWhenCacheKeyGeneratorIsNotSet() {
    this.cachingInterceptor.setCacheKeyGenerator(null);

    // execute the method to test.
    this.cachingInterceptor.afterPropertiesSet();

    CacheKeyGenerator assignedCacheKeyGenerator = this.cachingInterceptor
        .getCacheKeyGenerator();
    assertNotNull(assignedCacheKeyGenerator);

    Class expectedClass = HashCodeCacheKeyGenerator.class;
    assertEquals("<Key generator class>", expectedClass,
        assignedCacheKeyGenerator.getClass());
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#afterPropertiesSet()}</code> does not
   * change the key generator assigned to the interceptor.
   */
  public void testAfterPropertiesSetWhenCacheKeyGeneratorIsSet() {
    CacheKeyGenerator newCacheKeyGenerator = new HashCodeCacheKeyGenerator();
    this.cachingInterceptor = new CachingInterceptor();
    this.cachingInterceptor.setCacheKeyGenerator(newCacheKeyGenerator);

    // execute the method to test.
    this.cachingInterceptor.afterPropertiesSet();

    assertSame("<Key generator>", newCacheKeyGenerator, this.cachingInterceptor
        .getCacheKeyGenerator());
  }

  private void setStateOfMockControlsToReplay() {
    if (this.cacheKeyGeneratorControl != null) {
      this.cacheKeyGeneratorControl.replay();
    }

    this.cacheProviderFacadeControl.replay();
    this.cachingAttributeSourceControl.replay();

    if (this.entryStoredListenerControl != null) {
      this.entryStoredListenerControl.replay();
    }

    this.methodInvocationControl.replay();
  }

  private void verifyExpectationsOfMockControlsWereMet() {
    if (this.cacheKeyGeneratorControl != null) {
      this.cacheKeyGeneratorControl.verify();
    }

    this.cacheProviderFacadeControl.verify();
    this.cachingAttributeSourceControl.verify();

    if (this.entryStoredListenerControl != null) {
      this.entryStoredListenerControl.verify();
    }

    this.methodInvocationControl.verify();
  }

  private void assertSameCachingAttributes(Cached expected, Cached actual) {
    assertSame("<Caching attribute>", expected, actual);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#getCachingAttribute(MethodInvocation)}</code>
   * returns the instance of <code>{@link Cached}</code> retrieved from
   * <code>{@link #cachingAttributeSource}</code>.
   */
  public void testGetCachingAttribute() throws Exception {
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // expectation: get the target object for an invocation.
    this.methodInvocation.getThis();
    this.methodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching attribute of the intercepted method.
    this.cachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.cachingAttributeSourceControl.setReturnValue(this.cachingAttribute);

    this.setStateOfMockControlsToReplay();

    // execute the method to test.
    Cached returnedCachingAttribute = this.cachingInterceptor
        .getCachingAttribute(this.methodInvocation);

    this.assertSameCachingAttributes(this.cachingAttribute,
        returnedCachingAttribute);

    this.verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#getCachingAttribute(MethodInvocation)}</code>
   * returns the instance of <code>{@link Cached}</code> retrieved from
   * <code>{@link #cachingAttributeSource}</code> when
   * <code>MethodInvocation.getThis()</code> returns <code>null</code>.
   */
  public void testGetCachingAttributeWithMethodInvocationHavingThisObjectEqualToNull()
      throws Exception {

    Object thisObject = null;
    Class targetClass = null;

    // expectation: get the target object for an invocation.
    this.methodInvocation.getThis();
    this.methodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching attribute of the intercepted method.
    this.cachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.cachingAttributeSourceControl.setReturnValue(this.cachingAttribute);

    this.setStateOfMockControlsToReplay();

    // execute the method to test.
    Cached returnedCachingAttribute = this.cachingInterceptor
        .getCachingAttribute(this.methodInvocation);

    this.assertSameCachingAttributes(this.cachingAttribute,
        returnedCachingAttribute);

    this.verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> does not
   * store in the cache the return value of the intercepted method if the
   * intercepted method does not contain any caching attributes.
   */
  public void testInvokeHavingCachingAttributeEqualToNull() throws Throwable {
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // return value expected to be returned when executing the intercepted
    // method.
    Object expectedReturnValue = new Integer(10);

    // expectation: get the target object for an invocation.
    this.methodInvocation.getThis();
    this.methodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching attribute for the intercepted method. The
    // returned caching attribute should be null.
    this.cachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.cachingAttributeSourceControl.setReturnValue(null);

    // expectation: execute the intercepted method. The return value should not
    // be cached since there is not any caching attribute.
    this.methodInvocation.proceed();
    this.methodInvocationControl.setReturnValue(expectedReturnValue);

    this.setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualReturnValue = this.cachingInterceptor
        .invoke(this.methodInvocation);

    assertSame("<Returned Value>", expectedReturnValue, actualReturnValue);

    this.verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> returns
   * <code>null</code> if the cache already stored the returned value of the
   * intercepted method and the stored value is
   * <code>{@link CachingAspectSupport#NULL_ENTRY}</code>.
   */
  public void testInvokeHavingObjectInCacheEqualToNullEntry() throws Throwable {
    this.setUpCacheKey();
    this.setUpCacheKeyGeneratorAsMockObject();
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object cachedObject = CachingAspectSupport.NULL_ENTRY;

    // expectation: get the target object for an invocation.
    this.methodInvocation.getThis();
    this.methodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching attribute for the intercepted method.
    this.cachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.cachingAttributeSourceControl.setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.cacheKeyGenerator.generateKey(this.methodInvocation);
    this.cacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching attribute.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.cacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.cacheProviderFacadeControl.setReturnValue(cachedObject);

    this.setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualCachedObject = this.cachingInterceptor
        .invoke(this.methodInvocation);

    assertNull(actualCachedObject);

    this.verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code>
   * retrieves from the cache the stored return value of the intercepted method
   * and returns it instead of executing the method.
   */
  public void testInvokeHavingObjectInCacheNotEqualToNull() throws Throwable {
    this.setUpCacheKey();
    this.setUpCacheKeyGeneratorAsMockObject();
    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object expectedCachedObject = new Integer(4225);

    // expectation: get the target object for an invocation.
    this.methodInvocation.getThis();
    this.methodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching attribute for the intercepted method.
    this.cachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.cachingAttributeSourceControl.setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.cacheKeyGenerator.generateKey(this.methodInvocation);
    this.cacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching attribute.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.cacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.cacheProviderFacadeControl.setReturnValue(expectedCachedObject);

    this.setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualCachedObject = this.cachingInterceptor
        .invoke(this.methodInvocation);

    this.assertSameCachedObjects(expectedCachedObject, actualCachedObject);

    this.verifyExpectationsOfMockControlsWereMet();
  }

  private void assertSameCachedObjects(Object expected, Object actual) {
    assertSame("<Cached object>", expected, actual);
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> stores
   * in the cache the return value of the intercepted method and notifies the
   * listener that a new object has been saved in the cache.
   */
  public void testInvokeWhenObjectIsNotCachedAndInterceptorHasListener()
      throws Throwable {
    this.setUpCacheKey();
    this.setUpCacheKeyGeneratorAsMockObject();
    this.setUpEntryStoredListenerAsMockObject();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();
    Object proceedReturnValue = new Integer(434);

    // expectation: get the target object for an invocation.
    this.methodInvocation.getThis();
    this.methodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching attribute for the intercepted method.
    this.cachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.cachingAttributeSourceControl.setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.cacheKeyGenerator.generateKey(this.methodInvocation);
    this.cacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching attribute. There should not be any cached object.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.cacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.cacheProviderFacadeControl.setReturnValue(null);

    // expectation: since the object is not cached, execute the intercepted
    // method.
    this.methodInvocation.proceed();
    this.methodInvocationControl.setReturnValue(proceedReturnValue);

    // expectation: put in the cache the return value of the intercepted method.
    this.cacheProviderFacade.putInCache(this.cacheKey, cacheProfileId,
        proceedReturnValue);

    // expectation: notify the listener that a new entry has been added to the
    // cache.
    this.entryStoredListener.onEntryAdd(this.cacheKey, proceedReturnValue);

    this.setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualCachedObject = this.cachingInterceptor
        .invoke(this.methodInvocation);

    this.assertSameCachedObjects(proceedReturnValue, actualCachedObject);

    this.verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> stores
   * in the cache <code>{@link CachingAspectSupport#NULL_ENTRY}</code> if the
   * return value of the intercepted method is <code>null</code>.
   */
  public void testInvokeWhenObjectIsNotCachedAndProceedReturnsNull()
      throws Throwable {

    this.setUpCacheKey();
    this.setUpCacheKeyGeneratorAsMockObject();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // expectation: get the target object for an invocation.
    this.methodInvocation.getThis();
    this.methodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching attribute for the intercepted method.
    this.cachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.cachingAttributeSourceControl.setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.cacheKeyGenerator.generateKey(this.methodInvocation);
    this.cacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching attribute. There should not be any cached object.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.cacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.cacheProviderFacadeControl.setReturnValue(null);

    // expectation: since the object is not cached, execute the intercepted
    // method.
    this.methodInvocation.proceed();
    this.methodInvocationControl.setReturnValue(null);

    // expectation: put in the cache the return value of the intercepted method.
    this.cacheProviderFacade.putInCache(this.cacheKey, cacheProfileId,
        CachingAspectSupport.NULL_ENTRY);

    // set the state of the mock controls to 'replay'.
    this.setStateOfMockControlsToReplay();

    // execute the method to test.
    Object actualReturnedValue = this.cachingInterceptor
        .invoke(this.methodInvocation);

    assertNull("The return value of the intercepted method should be null",
        actualReturnedValue);

    this.verifyExpectationsOfMockControlsWereMet();
  }

  /**
   * Verifies that the method
   * <code>{@link CachingInterceptor#invoke(MethodInvocation)}</code> cancels
   * the update being made to the cache when a <code>Throwable</code> is
   * thrown when the intercepted method is being executed.
   */
  public void testInvokeWhenObjectIsNotCachedAndProceedThrowsThrowable()
      throws Throwable {

    this.setUpCacheKey();
    this.setUpCacheKeyGeneratorAsMockObject();

    Object thisObject = "A String!";
    Class targetClass = thisObject.getClass();

    // expectation: get the target object for an invocation.
    this.methodInvocation.getThis();
    this.methodInvocationControl.setReturnValue(thisObject);

    // expectation: get the caching attribute for the intercepted method.
    this.cachingAttributeSource.getCachingAttribute(this.interceptedMethod,
        targetClass);
    this.cachingAttributeSourceControl.setReturnValue(this.cachingAttribute);

    // expectation: generate the key for the object to cache (or already
    // cached).
    this.cacheKeyGenerator.generateKey(this.methodInvocation);
    this.cacheKeyGeneratorControl.setReturnValue(this.cacheKey);

    // expectation: get the object stored in the cache under the id retrieved
    // from the caching attribute. There should not be any cached object.
    String cacheProfileId = this.cachingAttribute.getCacheProfileId();
    this.cacheProviderFacade.getFromCache(this.cacheKey, cacheProfileId);
    this.cacheProviderFacadeControl.setReturnValue(null);

    // expectation: since the object is not cached, execute the intercepted
    // method. It should throw an exception.
    this.methodInvocation.proceed();
    this.methodInvocationControl.setThrowable(new Throwable());

    // expectation: cancel the update to the cache.
    this.cacheProviderFacade.cancelCacheUpdate(this.cacheKey);

    this.setStateOfMockControlsToReplay();

    // execute the method to test.
    try {
      this.cachingInterceptor.invoke(this.methodInvocation);
      fail("Expecting exception <" + Throwable.class.getName() + ">");
    } catch (Throwable throwable) {
      // we expect to catch this throwable.
    }

    this.verifyExpectationsOfMockControlsWereMet();
  }
}